{"version":3,"file":"bundle.min.js","sources":["../node_modules/hyparquet/src/constants.js","../node_modules/hyparquet/src/convert.js","../node_modules/hyparquet/src/schema.js","../node_modules/hyparquet/src/thrift.js","../node_modules/hyparquet/src/metadata.js","../node_modules/hyparquet/src/assemble.js","../node_modules/hyparquet/src/delta.js","../node_modules/hyparquet/src/encoding.js","../node_modules/hyparquet/src/plain.js","../node_modules/hyparquet/src/snappy.js","../node_modules/hyparquet/src/datapage.js","../node_modules/hyparquet/src/utils.js","../node_modules/hyparquet/src/column.js","../node_modules/hyparquet/src/read.js","../node_modules/hyparquet/src/query.js","../node_modules/hyparquet/src/hyparquet.js","../src/wkb.js","../src/index.js","demo.js"],"sourcesContent":["/** @type {import('../src/types.d.ts').ParquetType[]} */\nexport const ParquetType = [\n  'BOOLEAN',\n  'INT32',\n  'INT64',\n  'INT96', // deprecated\n  'FLOAT',\n  'DOUBLE',\n  'BYTE_ARRAY',\n  'FIXED_LEN_BYTE_ARRAY',\n]\n\nexport const Encoding = [\n  'PLAIN',\n  undefined,\n  'PLAIN_DICTIONARY',\n  'RLE',\n  'BIT_PACKED', // deprecated\n  'DELTA_BINARY_PACKED',\n  'DELTA_LENGTH_BYTE_ARRAY',\n  'DELTA_BYTE_ARRAY',\n  'RLE_DICTIONARY',\n  'BYTE_STREAM_SPLIT',\n]\n\nexport const FieldRepetitionType = [\n  'REQUIRED',\n  'OPTIONAL',\n  'REPEATED',\n]\n\n/** @type {import('../src/types.d.ts').ConvertedType[]} */\nexport const ConvertedType = [\n  'UTF8',\n  'MAP',\n  'MAP_KEY_VALUE',\n  'LIST',\n  'ENUM',\n  'DECIMAL',\n  'DATE',\n  'TIME_MILLIS',\n  'TIME_MICROS',\n  'TIMESTAMP_MILLIS',\n  'TIMESTAMP_MICROS',\n  'UINT_8',\n  'UINT_16',\n  'UINT_32',\n  'UINT_64',\n  'INT_8',\n  'INT_16',\n  'INT_32',\n  'INT_64',\n  'JSON',\n  'BSON',\n  'INTERVAL',\n]\n\n/** @type {import('../src/types.d.ts').LogicalTypeType[]} */\nexport const logicalTypeType = [\n  'NULL',\n  'STRING',\n  'MAP',\n  'LIST',\n  'ENUM',\n  'DECIMAL',\n  'DATE',\n  'TIME',\n  'TIMESTAMP',\n  'INTERVAL',\n  'INTEGER',\n  'NULL',\n  'JSON',\n  'BSON',\n  'UUID',\n]\n\nexport const CompressionCodec = [\n  'UNCOMPRESSED',\n  'SNAPPY',\n  'GZIP',\n  'LZO',\n  'BROTLI',\n  'LZ4',\n  'ZSTD',\n  'LZ4_RAW',\n]\n\n/** @type {import('../src/types.d.ts').PageType[]} */\nexport const PageType = [\n  'DATA_PAGE',\n  'INDEX_PAGE',\n  'DICTIONARY_PAGE',\n  'DATA_PAGE_V2',\n]\n\n/** @type {import('../src/types.d.ts').BoundaryOrder[]} */\nexport const BoundaryOrder = [\n  'UNORDERED',\n  'ASCENDING',\n  'DESCENDING',\n]\n","const dayMillis = 86400000 // 1 day in milliseconds\n\n/**\n * Convert known types from primitive to rich, and dereference dictionary.\n *\n * @import {DecodedArray, Encoding, SchemaElement} from '../src/types.d.ts'\n * @param {DecodedArray} data series of primitive types\n * @param {DecodedArray | undefined} dictionary\n * @param {SchemaElement} schemaElement\n * @param {Encoding} encoding\n * @param {boolean | undefined} utf8 decode bytes as utf8?\n * @returns {DecodedArray} series of rich types\n */\nexport function convertWithDictionary(data, dictionary, schemaElement, encoding, utf8 = true) {\n  if (dictionary && encoding.endsWith('_DICTIONARY')) {\n    // convert dictionary\n    dictionary = convert(dictionary, schemaElement, utf8)\n    let output = data\n    if (data instanceof Uint8Array && !(dictionary instanceof Uint8Array)) {\n      // @ts-expect-error upgrade data to match dictionary type with fancy constructor\n      output = new dictionary.constructor(data.length)\n    }\n    for (let i = 0; i < data.length; i++) {\n      output[i] = dictionary[data[i]]\n    }\n    return output\n  } else {\n    return convert(data, schemaElement, utf8)\n  }\n}\n\n/**\n * Convert known types from primitive to rich.\n *\n * @param {DecodedArray} data series of primitive types\n * @param {SchemaElement} schemaElement\n * @param {boolean | undefined} utf8 decode bytes as utf8?\n * @returns {DecodedArray} series of rich types\n */\nexport function convert(data, schemaElement, utf8 = true) {\n  const ctype = schemaElement.converted_type\n  if (ctype === 'DECIMAL') {\n    const scale = schemaElement.scale || 0\n    const factor = Math.pow(10, -scale)\n    const arr = new Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      if (data[0] instanceof Uint8Array) {\n        arr[i] = parseDecimal(data[i]) * factor\n      } else {\n        arr[i] = Number(data[i]) * factor\n      }\n    }\n    return arr\n  }\n  if (ctype === undefined && schemaElement.type === 'INT96') {\n    return Array.from(data).map(parseInt96Date)\n  }\n  if (ctype === 'DATE') {\n    const arr = new Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = new Date(data[i] * dayMillis)\n    }\n    return arr\n  }\n  if (ctype === 'TIMESTAMP_MILLIS') {\n    const arr = new Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = new Date(Number(data[i]))\n    }\n    return arr\n  }\n  if (ctype === 'TIMESTAMP_MICROS') {\n    const arr = new Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = new Date(Number(data[i] / 1000n))\n    }\n    return arr\n  }\n  if (ctype === 'JSON') {\n    const decoder = new TextDecoder()\n    return data.map(v => JSON.parse(decoder.decode(v)))\n  }\n  if (ctype === 'BSON') {\n    throw new Error('parquet bson not supported')\n  }\n  if (ctype === 'INTERVAL') {\n    throw new Error('parquet interval not supported')\n  }\n  if (ctype === 'UTF8' || utf8 && schemaElement.type === 'BYTE_ARRAY') {\n    const decoder = new TextDecoder()\n    const arr = new Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = data[i] && decoder.decode(data[i])\n    }\n    return arr\n  }\n  if (ctype === 'UINT_64') {\n    const arr = new BigUint64Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = BigInt(data[i])\n    }\n    return arr\n  }\n  if (schemaElement.logical_type?.type === 'FLOAT16') {\n    return Array.from(data).map(parseFloat16)\n  }\n  if (schemaElement.logical_type?.type === 'TIMESTAMP') {\n    const { unit } = schemaElement.logical_type\n    let factor = 1n\n    if (unit === 'MICROS') factor = 1000n\n    if (unit === 'NANOS') factor = 1000000n\n    const arr = new Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = new Date(Number(data[i] / factor))\n    }\n    return arr\n  }\n  return data\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {number}\n */\nexport function parseDecimal(bytes) {\n  // TODO: handle signed\n  let value = 0\n  for (const byte of bytes) {\n    value = value << 8 | byte\n  }\n  return value\n}\n\n/**\n * @param {bigint} value\n * @returns {Date}\n */\nfunction parseInt96Date(value) {\n  const days = Number((value >> 64n) - 2440588n)\n  const nano = Number((value & 0xffffffffffffffffn) / 1000000n)\n  const millis = days * dayMillis + nano\n  return new Date(millis)\n}\n\n/**\n * @param {Uint8Array | undefined} bytes\n * @returns {number | undefined}\n */\nexport function parseFloat16(bytes) {\n  if (!bytes) return undefined\n  const int16 = bytes[1] << 8 | bytes[0]\n  const sign = int16 >> 15 ? -1 : 1\n  const exp = int16 >> 10 & 0x1f\n  const frac = int16 & 0x3ff\n  if (exp === 0) return sign * Math.pow(2, -14) * (frac / 1024) // subnormals\n  if (exp === 0x1f) return frac ? NaN : sign * Infinity\n  return sign * Math.pow(2, exp - 15) * (1 + frac / 1024)\n}\n","/**\n * Build a tree from the schema elements.\n *\n * @import {SchemaElement, SchemaTree} from '../src/types.d.ts'\n * @param {SchemaElement[]} schema\n * @param {number} rootIndex index of the root element\n * @param {string[]} path path to the element\n * @returns {SchemaTree} tree of schema elements\n */\nfunction schemaTree(schema, rootIndex, path) {\n  const element = schema[rootIndex]\n  const children = []\n  let count = 1\n\n  // Read the specified number of children\n  if (element.num_children) {\n    while (children.length < element.num_children) {\n      const childElement = schema[rootIndex + count]\n      const child = schemaTree(schema, rootIndex + count, [...path, childElement.name])\n      count += child.count\n      children.push(child)\n    }\n  }\n\n  return { count, element, children, path }\n}\n\n/**\n * Get schema elements from the root to the given element name.\n *\n * @param {SchemaElement[]} schema\n * @param {string[]} name path to the element\n * @returns {SchemaTree[]} list of schema elements\n */\nexport function getSchemaPath(schema, name) {\n  let tree = schemaTree(schema, 0, [])\n  const path = [tree]\n  for (const part of name) {\n    const child = tree.children.find(child => child.element.name === part)\n    if (!child) throw new Error(`parquet schema element not found: ${name}`)\n    path.push(child)\n    tree = child\n  }\n  return path\n}\n\n/**\n * Get the max repetition level for a given schema path.\n *\n * @param {SchemaTree[]} schemaPath\n * @returns {number} max repetition level\n */\nexport function getMaxRepetitionLevel(schemaPath) {\n  let maxLevel = 0\n  for (const { element } of schemaPath) {\n    if (element.repetition_type === 'REPEATED') {\n      maxLevel++\n    }\n  }\n  return maxLevel\n}\n\n/**\n * Get the max definition level for a given schema path.\n *\n * @param {SchemaTree[]} schemaPath\n * @returns {number} max definition level\n */\nexport function getMaxDefinitionLevel(schemaPath) {\n  let maxLevel = 0\n  for (const { element } of schemaPath.slice(1)) {\n    if (element.repetition_type !== 'REQUIRED') {\n      maxLevel++\n    }\n  }\n  return maxLevel\n}\n\n/**\n * Check if a column is list-like.\n *\n * @param {SchemaTree} schema\n * @returns {boolean} true if list-like\n */\nexport function isListLike(schema) {\n  if (!schema) return false\n  if (schema.element.converted_type !== 'LIST') return false\n  if (schema.children.length > 1) return false\n\n  const firstChild = schema.children[0]\n  if (firstChild.children.length > 1) return false\n  if (firstChild.element.repetition_type !== 'REPEATED') return false\n\n  return true\n}\n\n/**\n * Check if a column is map-like.\n *\n * @param {SchemaTree} schema\n * @returns {boolean} true if map-like\n */\nexport function isMapLike(schema) {\n  if (!schema) return false\n  if (schema.element.converted_type !== 'MAP') return false\n  if (schema.children.length > 1) return false\n\n  const firstChild = schema.children[0]\n  if (firstChild.children.length !== 2) return false\n  if (firstChild.element.repetition_type !== 'REPEATED') return false\n\n  const keyChild = firstChild.children.find(child => child.element.name === 'key')\n  if (keyChild?.element.repetition_type === 'REPEATED') return false\n\n  const valueChild = firstChild.children.find(child => child.element.name === 'value')\n  if (valueChild?.element.repetition_type === 'REPEATED') return false\n\n  return true\n}\n","// TCompactProtocol types\nconst CompactType = {\n  STOP: 0,\n  TRUE: 1,\n  FALSE: 2,\n  BYTE: 3,\n  I16: 4,\n  I32: 5,\n  I64: 6,\n  DOUBLE: 7,\n  BINARY: 8,\n  LIST: 9,\n  SET: 10,\n  MAP: 11,\n  STRUCT: 12,\n  UUID: 13,\n}\n\n/**\n * Parse TCompactProtocol\n *\n * @import {DataReader} from '../src/types.d.ts'\n * @param {DataReader} reader\n * @returns {Record<string, any>}\n */\nexport function deserializeTCompactProtocol(reader) {\n  let lastFid = 0\n  /** @type {Record<string, any>} */\n  const value = {}\n\n  while (reader.offset < reader.view.byteLength) {\n    // Parse each field based on its type and add to the result object\n    const [type, fid, newLastFid] = readFieldBegin(reader, lastFid)\n    lastFid = newLastFid\n\n    if (type === CompactType.STOP) {\n      break\n    }\n\n    // Handle the field based on its type\n    value[`field_${fid}`] = readElement(reader, type)\n  }\n\n  return value\n}\n\n/**\n * Read a single element based on its type\n *\n * @param {DataReader} reader\n * @param {number} type\n * @returns {any} value\n */\nfunction readElement(reader, type) {\n  switch (type) {\n  case CompactType.TRUE:\n    return true\n  case CompactType.FALSE:\n    return false\n  case CompactType.BYTE:\n    // read byte directly\n    return reader.view.getInt8(reader.offset++)\n  case CompactType.I16:\n  case CompactType.I32:\n    return readZigZag(reader)\n  case CompactType.I64:\n    return readZigZagBigInt(reader)\n  case CompactType.DOUBLE: {\n    const value = reader.view.getFloat64(reader.offset, true)\n    reader.offset += 8\n    return value\n  }\n  case CompactType.BINARY: {\n    const stringLength = readVarInt(reader)\n    const strBytes = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, stringLength)\n    reader.offset += stringLength\n    return strBytes\n  }\n  case CompactType.LIST: {\n    const [elemType, listSize] = readCollectionBegin(reader)\n    const boolType = elemType === CompactType.TRUE || elemType === CompactType.FALSE\n    const values = new Array(listSize)\n    for (let i = 0; i < listSize; i++) {\n      values[i] = boolType ? readElement(reader, CompactType.BYTE) === 1 : readElement(reader, elemType)\n    }\n    return values\n  }\n  case CompactType.STRUCT: {\n    /** @type {Record<string, any>} */\n    const structValues = {}\n    let structLastFid = 0\n    while (true) {\n      let structFieldType, structFid\n      [structFieldType, structFid, structLastFid] = readFieldBegin(reader, structLastFid)\n      if (structFieldType === CompactType.STOP) {\n        break\n      }\n      structValues[`field_${structFid}`] = readElement(reader, structFieldType)\n    }\n    return structValues\n  }\n  // TODO: MAP and SET\n  case CompactType.UUID: {\n    // Read 16 bytes to uuid string\n    let uuid = ''\n    for (let i = 0; i < 16; i++) {\n      uuid += reader.view.getUint8(reader.offset++).toString(16).padStart(2, '0')\n    }\n    return uuid\n  }\n  default:\n    throw new Error(`thrift unhandled type: ${type}`)\n  }\n}\n\n/**\n * Var int, also known as Unsigned LEB128.\n * Var ints take 1 to 5 bytes (int32) or 1 to 10 bytes (int64).\n * Reads groups of 7 low bits until high bit is 0.\n *\n * @param {DataReader} reader\n * @returns {number} value\n */\nexport function readVarInt(reader) {\n  let result = 0\n  let shift = 0\n  while (true) {\n    const byte = reader.view.getUint8(reader.offset++)\n    result |= (byte & 0x7f) << shift\n    if (!(byte & 0x80)) {\n      return result\n    }\n    shift += 7\n  }\n}\n\n/**\n * Read a varint as a bigint.\n *\n * @param {DataReader} reader\n * @returns {bigint} value\n */\nfunction readVarBigInt(reader) {\n  let result = 0n\n  let shift = 0n\n  while (true) {\n    const byte = reader.view.getUint8(reader.offset++)\n    result |= BigInt(byte & 0x7f) << shift\n    if (!(byte & 0x80)) {\n      return result\n    }\n    shift += 7n\n  }\n}\n\n/**\n * Values of type int32 and int64 are transformed to a zigzag int.\n * A zigzag int folds positive and negative numbers into the positive number space.\n *\n * @param {DataReader} reader\n * @returns {number} value\n */\nfunction readZigZag(reader) {\n  const zigzag = readVarInt(reader)\n  // convert zigzag to int\n  return zigzag >>> 1 ^ -(zigzag & 1)\n}\n\n/**\n * A zigzag int folds positive and negative numbers into the positive number space.\n * This version returns a BigInt.\n *\n * @param {DataReader} reader\n * @returns {bigint} value\n */\nexport function readZigZagBigInt(reader) {\n  const zigzag = readVarBigInt(reader)\n  // convert zigzag to int\n  return zigzag >> BigInt(1) ^ -(zigzag & BigInt(1))\n}\n\n/**\n * Get thrift type from half a byte\n *\n * @param {number} byte\n * @returns {number}\n */\nfunction getCompactType(byte) {\n  return byte & 0x0f\n}\n\n/**\n * Read field type and field id\n *\n * @param {DataReader} reader\n * @param {number} lastFid\n * @returns {[number, number, number]} [type, fid, newLastFid]\n */\nfunction readFieldBegin(reader, lastFid) {\n  const type = reader.view.getUint8(reader.offset++)\n  if ((type & 0x0f) === CompactType.STOP) {\n    // STOP also ends a struct\n    return [0, 0, lastFid]\n  }\n  const delta = type >> 4\n  let fid // field id\n  if (delta) {\n    // add delta to last field id\n    fid = lastFid + delta\n  } else {\n    throw new Error('non-delta field id not supported')\n  }\n  return [getCompactType(type), fid, fid]\n}\n\n/**\n * Read collection type and size\n *\n * @param {DataReader} reader\n * @returns {[number, number]} [type, size]\n */\nfunction readCollectionBegin(reader) {\n  const sizeType = reader.view.getUint8(reader.offset++)\n  const size = sizeType >> 4\n  const type = getCompactType(sizeType)\n  if (size === 15) {\n    const newSize = readVarInt(reader)\n    return [type, newSize]\n  }\n  return [type, size]\n}\n\n/**\n * Convert int to varint. Outputs 1-5 bytes for int32.\n *\n * @param {number} n\n * @returns {number[]}\n */\nexport function toVarInt(n) {\n  let idx = 0\n  const varInt = []\n  while (true) {\n    if ((n & ~0x7f) === 0) {\n      varInt[idx++] = n\n      break\n    } else {\n      varInt[idx++] = n & 0x7f | 0x80\n      n >>>= 7\n    }\n  }\n  return varInt\n}\n","import { CompressionCodec, ConvertedType, Encoding, FieldRepetitionType, PageType, ParquetType } from './constants.js'\nimport { parseDecimal, parseFloat16 } from './convert.js'\nimport { getSchemaPath } from './schema.js'\nimport { deserializeTCompactProtocol } from './thrift.js'\n\n/**\n * Read parquet metadata from an async buffer.\n *\n * An AsyncBuffer is like an ArrayBuffer, but the slices are loaded\n * asynchronously, possibly over the network.\n *\n * You must provide the byteLength of the buffer, typically from a HEAD request.\n *\n * In theory, you could use suffix-range requests to fetch the end of the file,\n * and save a round trip. But in practice, this doesn't work because chrome\n * deems suffix-range requests as a not-safe-listed header, and will require\n * a pre-flight. So the byteLength is required.\n *\n * To make this efficient, we initially request the last 512kb of the file,\n * which is likely to contain the metadata. If the metadata length exceeds the\n * initial fetch, 512kb, we request the rest of the metadata from the AsyncBuffer.\n *\n * This ensures that we either make one 512kb initial request for the metadata,\n * or a second request for up to the metadata size.\n *\n * @param {AsyncBuffer} asyncBuffer parquet file contents\n * @param {number} initialFetchSize initial fetch size in bytes (default 512kb)\n * @returns {Promise<FileMetaData>} parquet metadata object\n */\nexport async function parquetMetadataAsync(asyncBuffer, initialFetchSize = 1 << 19 /* 512kb */) {\n  if (!asyncBuffer) throw new Error('parquet file is required')\n  if (!(asyncBuffer.byteLength >= 0)) throw new Error('parquet file byteLength is required')\n\n  // fetch last bytes (footer) of the file\n  const footerOffset = Math.max(0, asyncBuffer.byteLength - initialFetchSize)\n  const footerBuffer = await asyncBuffer.slice(footerOffset, asyncBuffer.byteLength)\n\n  // Check for parquet magic number \"PAR1\"\n  const footerView = new DataView(footerBuffer)\n  if (footerView.getUint32(footerBuffer.byteLength - 4, true) !== 0x31524150) {\n    throw new Error('parquet file invalid (footer != PAR1)')\n  }\n\n  // Parquet files store metadata at the end of the file\n  // Metadata length is 4 bytes before the last PAR1\n  const metadataLength = footerView.getUint32(footerBuffer.byteLength - 8, true)\n  if (metadataLength > asyncBuffer.byteLength - 8) {\n    throw new Error(`parquet metadata length ${metadataLength} exceeds available buffer ${asyncBuffer.byteLength - 8}`)\n  }\n\n  // check if metadata size fits inside the initial fetch\n  if (metadataLength + 8 > initialFetchSize) {\n    // fetch the rest of the metadata\n    const metadataOffset = asyncBuffer.byteLength - metadataLength - 8\n    const metadataBuffer = await asyncBuffer.slice(metadataOffset, footerOffset)\n    // combine initial fetch with the new slice\n    const combinedBuffer = new ArrayBuffer(metadataLength + 8)\n    const combinedView = new Uint8Array(combinedBuffer)\n    combinedView.set(new Uint8Array(metadataBuffer))\n    combinedView.set(new Uint8Array(footerBuffer), footerOffset - metadataOffset)\n    return parquetMetadata(combinedBuffer)\n  } else {\n    // parse metadata from the footer\n    return parquetMetadata(footerBuffer)\n  }\n}\n\n/**\n * Read parquet metadata from a buffer synchronously.\n *\n * @param {ArrayBuffer} arrayBuffer parquet file contents\n * @returns {FileMetaData} parquet metadata object\n */\nexport function parquetMetadata(arrayBuffer) {\n  if (!arrayBuffer) throw new Error('parquet file is required')\n  const view = new DataView(arrayBuffer)\n\n  // Validate footer magic number \"PAR1\"\n  if (view.byteLength < 8) {\n    throw new Error('parquet file is too short')\n  }\n  if (view.getUint32(view.byteLength - 4, true) !== 0x31524150) {\n    throw new Error('parquet file invalid (footer != PAR1)')\n  }\n\n  // Parquet files store metadata at the end of the file\n  // Metadata length is 4 bytes before the last PAR1\n  const metadataLengthOffset = view.byteLength - 8\n  const metadataLength = view.getUint32(metadataLengthOffset, true)\n  if (metadataLength > view.byteLength - 8) {\n    // {metadata}, metadata_length, PAR1\n    throw new Error(`parquet metadata length ${metadataLength} exceeds available buffer ${view.byteLength - 8}`)\n  }\n\n  const metadataOffset = metadataLengthOffset - metadataLength\n  const reader = { view, offset: metadataOffset }\n  const metadata = deserializeTCompactProtocol(reader)\n  const decoder = new TextDecoder()\n  function decode(/** @type {Uint8Array} */ value) {\n    return value && decoder.decode(value)\n  }\n\n  // Parse metadata from thrift data\n  const version = metadata.field_1\n  /** @type {SchemaElement[]} */\n  const schema = metadata.field_2.map((/** @type {any} */ field) => ({\n    type: ParquetType[field.field_1],\n    type_length: field.field_2,\n    repetition_type: FieldRepetitionType[field.field_3],\n    name: decode(field.field_4),\n    num_children: field.field_5,\n    converted_type: ConvertedType[field.field_6],\n    scale: field.field_7,\n    precision: field.field_8,\n    field_id: field.field_9,\n    logical_type: logicalType(field.field_10),\n  }))\n  // schema element per column index\n  const columnSchema = schema.filter(e => e.type)\n  const num_rows = metadata.field_3\n  const row_groups = metadata.field_4.map((/** @type {any} */ rowGroup) => ({\n    columns: rowGroup.field_1.map((/** @type {any} */ column, /** @type {number} */ columnIndex) => ({\n      file_path: decode(column.field_1),\n      file_offset: column.field_2,\n      meta_data: column.field_3 && {\n        type: ParquetType[column.field_3.field_1],\n        encodings: column.field_3.field_2?.map((/** @type {number} */ e) => Encoding[e]),\n        path_in_schema: column.field_3.field_3.map(decode),\n        codec: CompressionCodec[column.field_3.field_4],\n        num_values: column.field_3.field_5,\n        total_uncompressed_size: column.field_3.field_6,\n        total_compressed_size: column.field_3.field_7,\n        key_value_metadata: column.field_3.field_8,\n        data_page_offset: column.field_3.field_9,\n        index_page_offset: column.field_3.field_10,\n        dictionary_page_offset: column.field_3.field_11,\n        statistics: convertStats(column.field_3.field_12, columnSchema[columnIndex]),\n        encoding_stats: column.field_3.field_13?.map((/** @type {any} */ encodingStat) => ({\n          page_type: PageType[encodingStat.field_1],\n          encoding: Encoding[encodingStat.field_2],\n          count: encodingStat.field_3,\n        })),\n        bloom_filter_offset: column.field_3.field_14,\n        bloom_filter_length: column.field_3.field_15,\n        size_statistics: column.field_3.field_16 && {\n          unencoded_byte_array_data_bytes: column.field_3.field_16.field_1,\n          repetition_level_histogram: column.field_3.field_16.field_2,\n          definition_level_histogram: column.field_3.field_16.field_3,\n        },\n      },\n      offset_index_offset: column.field_4,\n      offset_index_length: column.field_5,\n      column_index_offset: column.field_6,\n      column_index_length: column.field_7,\n      crypto_metadata: column.field_7,\n      encrypted_column_metadata: column.field_8,\n    })),\n    total_byte_size: rowGroup.field_2,\n    num_rows: rowGroup.field_3,\n    sorting_columns: rowGroup.field_4?.map((/** @type {any} */ sortingColumn) => ({\n      column_idx: sortingColumn.field_1,\n      descending: sortingColumn.field_2,\n      nulls_first: sortingColumn.field_3,\n    })),\n    file_offset: rowGroup.field_5,\n    total_compressed_size: rowGroup.field_6,\n    ordinal: rowGroup.field_7,\n  }))\n  const key_value_metadata = metadata.field_5?.map((/** @type {any} */ keyValue) => ({\n    key: decode(keyValue.field_1),\n    value: decode(keyValue.field_2),\n  }))\n  const created_by = decode(metadata.field_6)\n\n  return {\n    version,\n    schema,\n    num_rows,\n    row_groups,\n    key_value_metadata,\n    created_by,\n    metadata_length: metadataLength,\n  }\n}\n\n/**\n * Return a tree of schema elements from parquet metadata.\n *\n * @param {FileMetaData} metadata parquet metadata object\n * @returns {SchemaTree} tree of schema elements\n */\nexport function parquetSchema(metadata) {\n  return getSchemaPath(metadata.schema, [])[0]\n}\n\n/**\n * @param {any} logicalType\n * @returns {LogicalType | undefined}\n */\nfunction logicalType(logicalType) {\n  if (logicalType?.field_1) return { type: 'STRING' }\n  if (logicalType?.field_2) return { type: 'MAP' }\n  if (logicalType?.field_3) return { type: 'LIST' }\n  if (logicalType?.field_4) return { type: 'ENUM' }\n  if (logicalType?.field_5) return {\n    type: 'DECIMAL',\n    scale: logicalType.field_5.field_1,\n    precision: logicalType.field_5.field_2,\n  }\n  if (logicalType?.field_6) return { type: 'DATE' }\n  if (logicalType?.field_7) return {\n    type: 'TIME',\n    isAdjustedToUTC: logicalType.field_7.field_1,\n    unit: timeUnit(logicalType.field_7.field_2),\n  }\n  if (logicalType?.field_8) return {\n    type: 'TIMESTAMP',\n    isAdjustedToUTC: logicalType.field_8.field_1,\n    unit: timeUnit(logicalType.field_8.field_2),\n  }\n  if (logicalType?.field_10) return {\n    type: 'INTEGER',\n    bitWidth: logicalType.field_10.field_1,\n    isSigned: logicalType.field_10.field_2,\n  }\n  if (logicalType?.field_11) return { type: 'NULL' }\n  if (logicalType?.field_12) return { type: 'JSON' }\n  if (logicalType?.field_13) return { type: 'BSON' }\n  if (logicalType?.field_14) return { type: 'UUID' }\n  if (logicalType?.field_15) return { type: 'FLOAT16' }\n  return logicalType\n}\n\n/**\n * @param {any} unit\n * @returns {TimeUnit}\n */\nfunction timeUnit(unit) {\n  if (unit.field_1) return 'MILLIS'\n  if (unit.field_2) return 'MICROS'\n  if (unit.field_3) return 'NANOS'\n  throw new Error('parquet time unit required')\n}\n\n/**\n * Convert column statistics based on column type.\n *\n * @import {AsyncBuffer, FileMetaData, LogicalType, MinMaxType, SchemaElement, SchemaTree, Statistics, TimeUnit} from '../src/types.d.ts'\n * @param {any} stats\n * @param {SchemaElement} schema\n * @returns {Statistics}\n */\nfunction convertStats(stats, schema) {\n  return stats && {\n    max: convertMetadata(stats.field_1, schema),\n    min: convertMetadata(stats.field_2, schema),\n    null_count: stats.field_3,\n    distinct_count: stats.field_4,\n    max_value: convertMetadata(stats.field_5, schema),\n    min_value: convertMetadata(stats.field_6, schema),\n    is_max_value_exact: stats.field_7,\n    is_min_value_exact: stats.field_8,\n  }\n}\n\n/**\n * @param {Uint8Array | undefined} value\n * @param {SchemaElement} schema\n * @returns {MinMaxType | undefined}\n */\nexport function convertMetadata(value, schema) {\n  const { type, converted_type, logical_type } = schema\n  if (value === undefined) return value\n  if (type === 'BOOLEAN') return value[0] === 1\n  if (type === 'BYTE_ARRAY') return new TextDecoder().decode(value)\n  const view = new DataView(value.buffer, value.byteOffset, value.byteLength)\n  if (type === 'FLOAT' && view.byteLength === 4) return view.getFloat32(0, true)\n  if (type === 'DOUBLE' && view.byteLength === 8) return view.getFloat64(0, true)\n  if (type === 'INT32' && converted_type === 'DATE') return new Date(view.getInt32(0, true) * 86400000)\n  if (type === 'INT64' && converted_type === 'TIMESTAMP_MICROS') return new Date(Number(view.getBigInt64(0, true) / 1000n))\n  if (type === 'INT64' && converted_type === 'TIMESTAMP_MILLIS') return new Date(Number(view.getBigInt64(0, true)))\n  if (type === 'INT64' && logical_type?.type === 'TIMESTAMP' && logical_type?.unit === 'NANOS') return new Date(Number(view.getBigInt64(0, true) / 1000000n))\n  if (type === 'INT64' && logical_type?.type === 'TIMESTAMP' && logical_type?.unit === 'MICROS') return new Date(Number(view.getBigInt64(0, true) / 1000n))\n  if (type === 'INT64' && logical_type?.type === 'TIMESTAMP') return new Date(Number(view.getBigInt64(0, true)))\n  if (type === 'INT32' && view.byteLength === 4) return view.getInt32(0, true)\n  if (type === 'INT64' && view.byteLength === 8) return view.getBigInt64(0, true)\n  if (converted_type === 'DECIMAL') return parseDecimal(value) * Math.pow(10, -(schema.scale || 0))\n  if (logical_type?.type === 'FLOAT16') return parseFloat16(value)\n  if (type === 'FIXED_LEN_BYTE_ARRAY') return value\n  // assert(false)\n  return value\n}\n","import { isListLike, isMapLike } from './schema.js'\n\n/**\n * Dremel-assembly of arrays of values into lists\n *\n * Reconstructs a complex nested structure from flat arrays of definition and repetition levels,\n * according to Dremel encoding.\n *\n * @import {DecodedArray, FieldRepetitionType} from '../src/types.d.ts'\n * @param {any[]} output\n * @param {number[] | undefined} definitionLevels\n * @param {number[]} repetitionLevels\n * @param {DecodedArray} values\n * @param {(FieldRepetitionType | undefined)[]} repetitionPath\n * @param {number} maxDefinitionLevel definition level that corresponds to non-null\n * @returns {any[]}\n */\nexport function assembleLists(\n  output, definitionLevels, repetitionLevels, values, repetitionPath, maxDefinitionLevel\n) {\n  const n = definitionLevels?.length || repetitionLevels.length\n  let valueIndex = 0\n\n  // Track state of nested structures\n  const containerStack = [output]\n  let currentContainer = output\n  let currentDepth = 0 // schema depth\n  let currentDefLevel = 0 // list depth\n  let currentRepLevel = 0\n\n  if (repetitionLevels[0]) {\n    // continue previous row\n    while (currentDepth < repetitionPath.length - 2 && currentRepLevel < repetitionLevels[0]) {\n      // go into last list\n      currentContainer = currentContainer.at(-1)\n      containerStack.push(currentContainer)\n      currentDepth++\n      if (repetitionPath[currentDepth] !== 'REQUIRED') currentDefLevel++\n      if (repetitionPath[currentDepth] === 'REPEATED') currentRepLevel++\n    }\n  }\n\n  for (let i = 0; i < n; i++) {\n    // assert(currentDefLevel === containerStack.length - 1)\n    const def = definitionLevels?.length ? definitionLevels[i] : maxDefinitionLevel\n    const rep = repetitionLevels[i]\n\n    // Pop up to start of rep level\n    while (currentDepth && (rep < currentRepLevel || repetitionPath[currentDepth] !== 'REPEATED')) {\n      if (repetitionPath[currentDepth] !== 'REQUIRED') {\n        containerStack.pop()\n        currentDefLevel--\n      }\n      if (repetitionPath[currentDepth] === 'REPEATED') currentRepLevel--\n      currentDepth--\n    }\n    // @ts-expect-error won't be empty\n    currentContainer = containerStack.at(-1)\n\n    // Go deeper to end of definition level\n    while (\n      (currentDepth < repetitionPath.length - 2 || repetitionPath[currentDepth + 1] === 'REPEATED') &&\n      (currentDefLevel < def || repetitionPath[currentDepth + 1] === 'REQUIRED')\n    ) {\n      currentDepth++\n      if (repetitionPath[currentDepth] !== 'REQUIRED') {\n        /** @type {any[]} */\n        const newList = []\n        currentContainer.push(newList)\n        currentContainer = newList\n        containerStack.push(newList)\n        currentDefLevel++\n      }\n      if (repetitionPath[currentDepth] === 'REPEATED') currentRepLevel++\n    }\n\n    // Add value or null based on definition level\n    if (def === maxDefinitionLevel) {\n      // assert(currentDepth === maxDefinitionLevel || currentDepth === repetitionPath.length - 2)\n      currentContainer.push(values[valueIndex++])\n    } else if (currentDepth === repetitionPath.length - 2) {\n      currentContainer.push(null)\n    } else {\n      currentContainer.push([])\n    }\n  }\n\n  // Handle edge cases for empty inputs or single-level data\n  if (!output.length) {\n    // return max definition level of nested lists\n    for (let i = 0; i < maxDefinitionLevel; i++) {\n      /** @type {any[]} */\n      const newList = []\n      currentContainer.push(newList)\n      currentContainer = newList\n    }\n  }\n\n  return output\n}\n\n/**\n * Assemble a nested structure from subcolumn data.\n * https://github.com/apache/parquet-format/blob/apache-parquet-format-2.10.0/LogicalTypes.md#nested-types\n *\n * @import {SchemaTree} from '../src/types.d.ts'\n * @param {Map<string, any[]>} subcolumnData\n * @param {SchemaTree} schema top-level schema element\n * @param {number} [depth] depth of nested structure\n */\nexport function assembleNested(subcolumnData, schema, depth = 0) {\n  const path = schema.path.join('.')\n  const optional = schema.element.repetition_type === 'OPTIONAL'\n  const nextDepth = optional ? depth + 1 : depth\n\n  if (isListLike(schema)) {\n    let sublist = schema.children[0]\n    let subDepth = nextDepth\n    if (sublist.children.length === 1) {\n      sublist = sublist.children[0]\n      subDepth++\n    }\n    assembleNested(subcolumnData, sublist, subDepth)\n\n    const subcolumn = sublist.path.join('.')\n    const values = subcolumnData.get(subcolumn)\n    if (!values) throw new Error('parquet list column missing values')\n    if (optional) flattenAtDepth(values, depth)\n    subcolumnData.set(path, values)\n    subcolumnData.delete(subcolumn)\n    return\n  }\n\n  if (isMapLike(schema)) {\n    const mapName = schema.children[0].element.name\n\n    // Assemble keys and values\n    assembleNested(subcolumnData, schema.children[0].children[0], nextDepth + 1)\n    assembleNested(subcolumnData, schema.children[0].children[1], nextDepth + 1)\n\n    const keys = subcolumnData.get(`${path}.${mapName}.key`)\n    const values = subcolumnData.get(`${path}.${mapName}.value`)\n\n    if (!keys) throw new Error('parquet map column missing keys')\n    if (!values) throw new Error('parquet map column missing values')\n    if (keys.length !== values.length) {\n      throw new Error('parquet map column key/value length mismatch')\n    }\n\n    const out = assembleMaps(keys, values, nextDepth)\n    if (optional) flattenAtDepth(out, depth)\n\n    subcolumnData.delete(`${path}.${mapName}.key`)\n    subcolumnData.delete(`${path}.${mapName}.value`)\n    subcolumnData.set(path, out)\n    return\n  }\n\n  // Struct-like column\n  if (schema.children.length) {\n    // construct a meta struct and then invert\n    const invertDepth = schema.element.repetition_type === 'REQUIRED' ? depth : depth + 1\n    /** @type {Record<string, any>} */\n    const struct = {}\n    for (const child of schema.children) {\n      assembleNested(subcolumnData, child, invertDepth)\n      const childData = subcolumnData.get(child.path.join('.'))\n      if (!childData) throw new Error('parquet struct missing child data')\n      struct[child.element.name] = childData\n    }\n    // remove children\n    for (const child of schema.children) {\n      subcolumnData.delete(child.path.join('.'))\n    }\n    // invert struct by depth\n    const inverted = invertStruct(struct, invertDepth)\n    if (optional) flattenAtDepth(inverted, depth)\n    subcolumnData.set(path, inverted)\n  }\n}\n\n/**\n * @param {any[]} arr\n * @param {number} depth\n */\nfunction flattenAtDepth(arr, depth) {\n  for (let i = 0; i < arr.length; i++) {\n    if (depth) {\n      flattenAtDepth(arr[i], depth - 1)\n    } else {\n      arr[i] = arr[i][0]\n    }\n  }\n}\n\n/**\n * @param {any[]} keys\n * @param {any[]} values\n * @param {number} depth\n * @returns {any[]}\n */\nfunction assembleMaps(keys, values, depth) {\n  const out = []\n  for (let i = 0; i < keys.length; i++) {\n    if (depth) {\n      out.push(assembleMaps(keys[i], values[i], depth - 1)) // go deeper\n    } else {\n      if (keys[i]) {\n        /** @type {Record<string, any>} */\n        const obj = {}\n        for (let j = 0; j < keys[i].length; j++) {\n          const value = values[i][j]\n          obj[keys[i][j]] = value === undefined ? null : value\n        }\n        out.push(obj)\n      } else {\n        out.push(undefined)\n      }\n    }\n  }\n  return out\n}\n\n/**\n * Invert a struct-like object by depth.\n *\n * @param {Record<string, any[]>} struct\n * @param {number} depth\n * @returns {any[]}\n */\nfunction invertStruct(struct, depth) {\n  const keys = Object.keys(struct)\n  const length = struct[keys[0]]?.length\n  const out = []\n  for (let i = 0; i < length; i++) {\n    /** @type {Record<string, any>} */\n    const obj = {}\n    for (const key of keys) {\n      if (struct[key].length !== length) throw new Error('parquet struct parsing error')\n      obj[key] = struct[key][i]\n    }\n    if (depth) {\n      out.push(invertStruct(obj, depth - 1)) // deeper\n    } else {\n      out.push(obj)\n    }\n  }\n  return out\n}\n","import { readVarInt, readZigZagBigInt } from './thrift.js'\n\n/**\n * @import {DataReader} from '../src/types.d.ts'\n * @param {DataReader} reader\n * @param {number} count number of values to read\n * @param {Int32Array | BigInt64Array} output\n */\nexport function deltaBinaryUnpack(reader, count, output) {\n  const int32 = output instanceof Int32Array\n  const blockSize = readVarInt(reader)\n  const miniblockPerBlock = readVarInt(reader)\n  readVarInt(reader) // assert(=== count)\n  let value = readZigZagBigInt(reader) // first value\n  let outputIndex = 0\n  output[outputIndex++] = int32 ? Number(value) : value\n\n  const valuesPerMiniblock = blockSize / miniblockPerBlock\n\n  while (outputIndex < count) {\n    // new block\n    const minDelta = readZigZagBigInt(reader)\n    const bitWidths = new Uint8Array(miniblockPerBlock)\n    for (let i = 0; i < miniblockPerBlock; i++) {\n      bitWidths[i] = reader.view.getUint8(reader.offset++)\n    }\n\n    for (let i = 0; i < miniblockPerBlock && outputIndex < count; i++) {\n      // new miniblock\n      const bitWidth = BigInt(bitWidths[i])\n      if (bitWidth) {\n        let bitpackPos = 0n\n        let miniblockCount = valuesPerMiniblock\n        const mask = (1n << bitWidth) - 1n\n        while (miniblockCount && outputIndex < count) {\n          let bits = BigInt(reader.view.getUint8(reader.offset)) >> bitpackPos & mask // TODO: don't re-read value every time\n          bitpackPos += bitWidth\n          while (bitpackPos >= 8) {\n            bitpackPos -= 8n\n            reader.offset++\n            if (bitpackPos) {\n              bits |= BigInt(reader.view.getUint8(reader.offset)) << bitWidth - bitpackPos & mask\n            }\n          }\n          const delta = minDelta + bits\n          value += delta\n          output[outputIndex++] = int32 ? Number(value) : value\n          miniblockCount--\n        }\n        if (miniblockCount) {\n          // consume leftover miniblock\n          reader.offset += Math.ceil((miniblockCount * Number(bitWidth) + Number(bitpackPos)) / 8)\n        }\n      } else {\n        for (let j = 0; j < valuesPerMiniblock && outputIndex < count; j++) {\n          value += minDelta\n          output[outputIndex++] = int32 ? Number(value) : value\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {DataReader} reader\n * @param {number} count\n * @param {Uint8Array[]} output\n */\nexport function deltaLengthByteArray(reader, count, output) {\n  const lengths = new Int32Array(count)\n  deltaBinaryUnpack(reader, count, lengths)\n  for (let i = 0; i < count; i++) {\n    output[i] = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, lengths[i])\n    reader.offset += lengths[i]\n  }\n}\n\n/**\n * @param {DataReader} reader\n * @param {number} count\n * @param {Uint8Array[]} output\n */\nexport function deltaByteArray(reader, count, output) {\n  const prefixData = new Int32Array(count)\n  deltaBinaryUnpack(reader, count, prefixData)\n  const suffixData = new Int32Array(count)\n  deltaBinaryUnpack(reader, count, suffixData)\n\n  for (let i = 0; i < count; i++) {\n    const suffix = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, suffixData[i])\n    if (prefixData[i]) {\n      // copy from previous value\n      output[i] = new Uint8Array(prefixData[i] + suffixData[i])\n      output[i].set(output[i - 1].subarray(0, prefixData[i]))\n      output[i].set(suffix, prefixData[i])\n    } else {\n      output[i] = suffix\n    }\n    reader.offset += suffixData[i]\n  }\n}\n","import { readVarInt } from './thrift.js'\n\n/**\n * Minimum bits needed to store value.\n *\n * @param {number} value\n * @returns {number}\n */\nexport function bitWidth(value) {\n  return 32 - Math.clz32(value)\n}\n\n/**\n * Read values from a run-length encoded/bit-packed hybrid encoding.\n *\n * If length is zero, then read int32 length at the start.\n *\n * @param {DataReader} reader\n * @param {number} width - width of each bit-packed group\n * @param {number} length - length of the encoded data\n * @param {DecodedArray} output\n */\nexport function readRleBitPackedHybrid(reader, width, length, output) {\n  if (!length) {\n    // length = reader.view.getUint32(reader.offset, true)\n    reader.offset += 4\n  }\n  let seen = 0\n  while (seen < output.length) {\n    const header = readVarInt(reader)\n    if (header & 1) {\n      // bit-packed\n      seen = readBitPacked(reader, header, width, output, seen)\n    } else {\n      // rle\n      const count = header >>> 1\n      readRle(reader, count, width, output, seen)\n      seen += count\n    }\n  }\n  // assert(reader.offset - startOffset === length)\n}\n\n/**\n * Run-length encoding: read value with bitWidth and repeat it count times.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @param {number} bitWidth\n * @param {DecodedArray} output\n * @param {number} seen\n */\nfunction readRle(reader, count, bitWidth, output, seen) {\n  const width = bitWidth + 7 >> 3\n  let value = 0\n  for (let i = 0; i < width; i++) {\n    value |= reader.view.getUint8(reader.offset++) << (i << 3)\n  }\n  // assert(value < 1 << bitWidth)\n\n  // repeat value count times\n  for (let i = 0; i < count; i++) {\n    output[seen + i] = value\n  }\n}\n\n/**\n * Read a bit-packed run of the rle/bitpack hybrid.\n * Supports width > 8 (crossing bytes).\n *\n * @param {DataReader} reader\n * @param {number} header - bit-pack header\n * @param {number} bitWidth\n * @param {DecodedArray} output\n * @param {number} seen\n * @returns {number} total output values so far\n */\nfunction readBitPacked(reader, header, bitWidth, output, seen) {\n  let count = header >> 1 << 3 // values to read\n  const mask = (1 << bitWidth) - 1\n\n  let data = 0\n  if (reader.offset < reader.view.byteLength) {\n    data = reader.view.getUint8(reader.offset++)\n  } else if (mask) {\n    // sometimes out-of-bounds reads are masked out\n    throw new Error(`parquet bitpack offset ${reader.offset} out of range`)\n  }\n  let left = 8\n  let right = 0\n\n  // read values\n  while (count) {\n    // if we have crossed a byte boundary, shift the data\n    if (right > 8) {\n      right -= 8\n      left -= 8\n      data >>>= 8\n    } else if (left - right < bitWidth) {\n      // if we don't have bitWidth number of bits to read, read next byte\n      data |= reader.view.getUint8(reader.offset) << left\n      reader.offset++\n      left += 8\n    } else {\n      if (seen < output.length) {\n        // emit value\n        output[seen++] = data >> right & mask\n      }\n      count--\n      right += bitWidth\n    }\n  }\n\n  return seen\n}\n\n/**\n * @param {DataReader} reader\n * @param {number} count\n * @param {ParquetType} type\n * @param {number | undefined} typeLength\n * @returns {DecodedArray}\n */\nexport function byteStreamSplit(reader, count, type, typeLength) {\n  const width = byteWidth(type, typeLength)\n  const bytes = new Uint8Array(count * width)\n  for (let b = 0; b < width; b++) {\n    for (let i = 0; i < count; i++) {\n      bytes[i * width + b] = reader.view.getUint8(reader.offset++)\n    }\n  }\n  // interpret bytes as typed array\n  if (type === 'FLOAT') return new Float32Array(bytes.buffer)\n  else if (type === 'DOUBLE') return new Float64Array(bytes.buffer)\n  else if (type === 'INT32') return new Int32Array(bytes.buffer)\n  else if (type === 'INT64') return new BigInt64Array(bytes.buffer)\n  else if (type === 'FIXED_LEN_BYTE_ARRAY') {\n    // split into arrays of typeLength\n    const split = new Array(count)\n    for (let i = 0; i < count; i++) {\n      split[i] = bytes.subarray(i * width, (i + 1) * width)\n    }\n    return split\n  }\n  throw new Error(`parquet byte_stream_split unsupported type: ${type}`)\n}\n\n/**\n * @import {DataReader, DecodedArray, ParquetType} from '../src/types.d.ts'\n * @param {ParquetType} type\n * @param {number | undefined} typeLength\n * @returns {number}\n */\nfunction byteWidth(type, typeLength) {\n  switch (type) {\n  case 'INT32':\n  case 'FLOAT':\n    return 4\n  case 'INT64':\n  case 'DOUBLE':\n    return 8\n  case 'FIXED_LEN_BYTE_ARRAY':\n    if (!typeLength) throw new Error('parquet byteWidth missing type_length')\n    return typeLength\n  default:\n    throw new Error(`parquet unsupported type: ${type}`)\n  }\n}\n","/**\n * Read `count` values of the given type from the reader.view.\n *\n * @import {DataReader, DecodedArray, ParquetType} from '../src/types.d.ts'\n * @param {DataReader} reader - buffer to read data from\n * @param {ParquetType} type - parquet type of the data\n * @param {number} count - number of values to read\n * @param {number | undefined} fixedLength - length of each fixed length byte array\n * @returns {DecodedArray} array of values\n */\nexport function readPlain(reader, type, count, fixedLength) {\n  if (count === 0) return []\n  if (type === 'BOOLEAN') {\n    return readPlainBoolean(reader, count)\n  } else if (type === 'INT32') {\n    return readPlainInt32(reader, count)\n  } else if (type === 'INT64') {\n    return readPlainInt64(reader, count)\n  } else if (type === 'INT96') {\n    return readPlainInt96(reader, count)\n  } else if (type === 'FLOAT') {\n    return readPlainFloat(reader, count)\n  } else if (type === 'DOUBLE') {\n    return readPlainDouble(reader, count)\n  } else if (type === 'BYTE_ARRAY') {\n    return readPlainByteArray(reader, count)\n  } else if (type === 'FIXED_LEN_BYTE_ARRAY') {\n    if (!fixedLength) throw new Error('parquet missing fixed length')\n    return readPlainByteArrayFixed(reader, count, fixedLength)\n  } else {\n    throw new Error(`parquet unhandled type: ${type}`)\n  }\n}\n\n/**\n * Read `count` boolean values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {boolean[]}\n */\nfunction readPlainBoolean(reader, count) {\n  const values = new Array(count)\n  for (let i = 0; i < count; i++) {\n    const byteOffset = reader.offset + (i / 8 | 0)\n    const bitOffset = i % 8\n    const byte = reader.view.getUint8(byteOffset)\n    values[i] = (byte & 1 << bitOffset) !== 0\n  }\n  reader.offset += Math.ceil(count / 8)\n  return values\n}\n\n/**\n * Read `count` int32 values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {Int32Array}\n */\nfunction readPlainInt32(reader, count) {\n  const values = (reader.view.byteOffset + reader.offset) % 4\n    ? new Int32Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 4))\n    : new Int32Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)\n  reader.offset += count * 4\n  return values\n}\n\n/**\n * Read `count` int64 values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {BigInt64Array}\n */\nfunction readPlainInt64(reader, count) {\n  const values = (reader.view.byteOffset + reader.offset) % 8\n    ? new BigInt64Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 8))\n    : new BigInt64Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)\n  reader.offset += count * 8\n  return values\n}\n\n/**\n * Read `count` int96 values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {bigint[]}\n */\nfunction readPlainInt96(reader, count) {\n  const values = new Array(count)\n  for (let i = 0; i < count; i++) {\n    const low = reader.view.getBigInt64(reader.offset + i * 12, true)\n    const high = reader.view.getInt32(reader.offset + i * 12 + 8, true)\n    values[i] = BigInt(high) << 64n | low\n  }\n  reader.offset += count * 12\n  return values\n}\n\n/**\n * Read `count` float values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {Float32Array}\n */\nfunction readPlainFloat(reader, count) {\n  const values = (reader.view.byteOffset + reader.offset) % 4\n    ? new Float32Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 4))\n    : new Float32Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)\n  reader.offset += count * 4\n  return values\n}\n\n/**\n * Read `count` double values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {Float64Array}\n */\nfunction readPlainDouble(reader, count) {\n  const values = (reader.view.byteOffset + reader.offset) % 8\n    ? new Float64Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 8))\n    : new Float64Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)\n  reader.offset += count * 8\n  return values\n}\n\n/**\n * Read `count` byte array values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {Uint8Array[]}\n */\nfunction readPlainByteArray(reader, count) {\n  const values = new Array(count)\n  for (let i = 0; i < count; i++) {\n    const length = reader.view.getInt32(reader.offset, true)\n    reader.offset += 4\n    values[i] = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, length)\n    reader.offset += length\n  }\n  return values\n}\n\n/**\n * Read a fixed length byte array.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @param {number} fixedLength\n * @returns {Uint8Array[]}\n */\nfunction readPlainByteArrayFixed(reader, count, fixedLength) {\n  // assert(reader.view.byteLength - reader.offset >= count * fixedLength)\n  const values = new Array(count)\n  for (let i = 0; i < count; i++) {\n    values[i] = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, fixedLength)\n    reader.offset += fixedLength\n  }\n  return values\n}\n\n/**\n * Create a new buffer with the offset and size.\n *\n * @param {ArrayBufferLike} buffer\n * @param {number} offset\n * @param {number} size\n * @returns {ArrayBuffer}\n */\nfunction align(buffer, offset, size) {\n  const aligned = new ArrayBuffer(size)\n  new Uint8Array(aligned).set(new Uint8Array(buffer, offset, size))\n  return aligned\n}\n","/**\n * The MIT License (MIT)\n * Copyright (c) 2016 Zhipeng Jia\n * https://github.com/zhipeng-jia/snappyjs\n */\n\nconst WORD_MASK = [0, 0xff, 0xffff, 0xffffff, 0xffffffff]\n\n/**\n * Copy bytes from one array to another\n *\n * @param {Uint8Array} fromArray source array\n * @param {number} fromPos source position\n * @param {Uint8Array} toArray destination array\n * @param {number} toPos destination position\n * @param {number} length number of bytes to copy\n * @returns {void}\n */\nfunction copyBytes(fromArray, fromPos, toArray, toPos, length) {\n  for (let i = 0; i < length; i++) {\n    toArray[toPos + i] = fromArray[fromPos + i]\n  }\n}\n\n/**\n * Copy bytes within an array\n *\n * @param {Uint8Array} array source and destination array\n * @param {number} pos source position\n * @param {number} offset offset back from current position to read\n * @param {number} length number of bytes to copy\n * @returns {void}\n */\nfunction selfCopyBytes(array, pos, offset, length) {\n  for (let i = 0; i < length; i++) {\n    array[pos + i] = array[pos - offset + i]\n  }\n}\n\n/**\n * Decompress snappy data.\n * Accepts an output buffer to avoid allocating a new buffer for each call.\n *\n * @param {Uint8Array} input compressed data\n * @param {Uint8Array} output output buffer\n * @returns {void}\n */\nexport function snappyUncompress(input, output) {\n  const inputLength = input.byteLength\n  const outputLength = output.byteLength\n  let pos = 0\n  let outPos = 0\n\n  // skip preamble (contains uncompressed length as varint)\n  while (pos < inputLength) {\n    const c = input[pos]\n    pos++\n    if (c < 128) {\n      break\n    }\n  }\n  if (outputLength && pos >= inputLength) {\n    throw new Error('invalid snappy length header')\n  }\n\n  while (pos < inputLength) {\n    const c = input[pos]\n    let len = 0\n    pos++\n\n    if (pos >= inputLength) {\n      throw new Error('missing eof marker')\n    }\n\n    // There are two types of elements, literals and copies (back references)\n    if ((c & 0x3) === 0) {\n      // Literals are uncompressed data stored directly in the byte stream\n      let len = (c >>> 2) + 1\n      // Longer literal length is encoded in multiple bytes\n      if (len > 60) {\n        if (pos + 3 >= inputLength) {\n          throw new Error('snappy error literal pos + 3 >= inputLength')\n        }\n        const lengthSize = len - 60 // length bytes - 1\n        len = input[pos]\n          + (input[pos + 1] << 8)\n          + (input[pos + 2] << 16)\n          + (input[pos + 3] << 24)\n        len = (len & WORD_MASK[lengthSize]) + 1\n        pos += lengthSize\n      }\n      if (pos + len > inputLength) {\n        throw new Error('snappy error literal exceeds input length')\n      }\n      copyBytes(input, pos, output, outPos, len)\n      pos += len\n      outPos += len\n    } else {\n      // Copy elements\n      let offset = 0 // offset back from current position to read\n      switch (c & 0x3) {\n      case 1:\n        // Copy with 1-byte offset\n        len = (c >>> 2 & 0x7) + 4\n        offset = input[pos] + (c >>> 5 << 8)\n        pos++\n        break\n      case 2:\n        // Copy with 2-byte offset\n        if (inputLength <= pos + 1) {\n          throw new Error('snappy error end of input')\n        }\n        len = (c >>> 2) + 1\n        offset = input[pos] + (input[pos + 1] << 8)\n        pos += 2\n        break\n      case 3:\n        // Copy with 4-byte offset\n        if (inputLength <= pos + 3) {\n          throw new Error('snappy error end of input')\n        }\n        len = (c >>> 2) + 1\n        offset = input[pos]\n          + (input[pos + 1] << 8)\n          + (input[pos + 2] << 16)\n          + (input[pos + 3] << 24)\n        pos += 4\n        break\n      default:\n        break\n      }\n      if (offset === 0 || isNaN(offset)) {\n        throw new Error(`invalid offset ${offset} pos ${pos} inputLength ${inputLength}`)\n      }\n      if (offset > outPos) {\n        throw new Error('cannot copy from before start of buffer')\n      }\n      selfCopyBytes(output, outPos, offset, len)\n      outPos += len\n    }\n  }\n\n  if (outPos !== outputLength) throw new Error('premature end of input')\n}\n","import { deltaBinaryUnpack, deltaByteArray, deltaLengthByteArray } from './delta.js'\nimport { bitWidth, byteStreamSplit, readRleBitPackedHybrid } from './encoding.js'\nimport { readPlain } from './plain.js'\nimport { getMaxDefinitionLevel, getMaxRepetitionLevel } from './schema.js'\nimport { snappyUncompress } from './snappy.js'\n\n/**\n * Read a data page from uncompressed reader.\n *\n * @param {Uint8Array} bytes raw page data (should already be decompressed)\n * @param {DataPageHeader} daph data page header\n * @param {SchemaTree[]} schemaPath\n * @param {ColumnMetaData} columnMetadata\n * @returns {DataPage} definition levels, repetition levels, and array of values\n */\nexport function readDataPage(bytes, daph, schemaPath, { type }) {\n  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  const reader = { view, offset: 0 }\n  /** @type {DecodedArray} */\n  let dataPage\n\n  // repetition and definition levels\n  const repetitionLevels = readRepetitionLevels(reader, daph, schemaPath)\n  // assert(!repetitionLevels.length || repetitionLevels.length === daph.num_values)\n  const { definitionLevels, numNulls } = readDefinitionLevels(reader, daph, schemaPath)\n  // assert(!definitionLevels.length || definitionLevels.length === daph.num_values)\n\n  // read values based on encoding\n  const nValues = daph.num_values - numNulls\n  if (daph.encoding === 'PLAIN') {\n    const { type_length } = schemaPath[schemaPath.length - 1].element\n    dataPage = readPlain(reader, type, nValues, type_length)\n  } else if (\n    daph.encoding === 'PLAIN_DICTIONARY' ||\n    daph.encoding === 'RLE_DICTIONARY' ||\n    daph.encoding === 'RLE'\n  ) {\n    const bitWidth = type === 'BOOLEAN' ? 1 : view.getUint8(reader.offset++)\n    if (bitWidth) {\n      dataPage = new Array(nValues)\n      readRleBitPackedHybrid(reader, bitWidth, view.byteLength - reader.offset, dataPage)\n    } else {\n      dataPage = new Uint8Array(nValues) // nValue zeroes\n    }\n  } else if (daph.encoding === 'BYTE_STREAM_SPLIT') {\n    const { type_length } = schemaPath[schemaPath.length - 1].element\n    dataPage = byteStreamSplit(reader, nValues, type, type_length)\n  } else {\n    throw new Error(`parquet unsupported encoding: ${daph.encoding}`)\n  }\n\n  return { definitionLevels, repetitionLevels, dataPage }\n}\n\n/**\n * @param {Uint8Array} bytes raw page data\n * @param {DictionaryPageHeader} diph dictionary page header\n * @param {ColumnMetaData} columnMetadata\n * @param {number | undefined} typeLength - type_length from schema\n * @returns {DecodedArray}\n */\nexport function readDictionaryPage(bytes, diph, columnMetadata, typeLength) {\n  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  const reader = { view, offset: 0 }\n  return readPlain(reader, columnMetadata.type, diph.num_values, typeLength)\n}\n\n/**\n * @import {ColumnMetaData, CompressionCodec, Compressors, DataPage, DataPageHeader, DataPageHeaderV2, DataReader, DecodedArray, DictionaryPageHeader, PageHeader, SchemaTree} from '../src/types.d.ts'\n * @param {DataReader} reader data view for the page\n * @param {DataPageHeader} daph data page header\n * @param {SchemaTree[]} schemaPath\n * @returns {any[]} repetition levels and number of bytes read\n */\nfunction readRepetitionLevels(reader, daph, schemaPath) {\n  if (schemaPath.length > 1) {\n    const maxRepetitionLevel = getMaxRepetitionLevel(schemaPath)\n    if (maxRepetitionLevel) {\n      const values = new Array(daph.num_values)\n      readRleBitPackedHybrid(reader, bitWidth(maxRepetitionLevel), 0, values)\n      return values\n    }\n  }\n  return []\n}\n\n/**\n * @param {DataReader} reader data view for the page\n * @param {DataPageHeader} daph data page header\n * @param {SchemaTree[]} schemaPath\n * @returns {{ definitionLevels: number[], numNulls: number }} definition levels\n */\nfunction readDefinitionLevels(reader, daph, schemaPath) {\n  const maxDefinitionLevel = getMaxDefinitionLevel(schemaPath)\n  if (!maxDefinitionLevel) return { definitionLevels: [], numNulls: 0 }\n\n  const definitionLevels = new Array(daph.num_values)\n  readRleBitPackedHybrid(reader, bitWidth(maxDefinitionLevel), 0, definitionLevels)\n\n  // count nulls\n  let numNulls = daph.num_values\n  for (const def of definitionLevels) {\n    if (def === maxDefinitionLevel) numNulls--\n  }\n  if (numNulls === 0) definitionLevels.length = 0\n\n  return { definitionLevels, numNulls }\n}\n\n/**\n * @param {Uint8Array} compressedBytes\n * @param {number} uncompressed_page_size\n * @param {CompressionCodec} codec\n * @param {Compressors | undefined} compressors\n * @returns {Uint8Array}\n */\nexport function decompressPage(compressedBytes, uncompressed_page_size, codec, compressors) {\n  /** @type {Uint8Array} */\n  let page\n  const customDecompressor = compressors?.[codec]\n  if (codec === 'UNCOMPRESSED') {\n    page = compressedBytes\n  } else if (customDecompressor) {\n    page = customDecompressor(compressedBytes, uncompressed_page_size)\n  } else if (codec === 'SNAPPY') {\n    page = new Uint8Array(uncompressed_page_size)\n    snappyUncompress(compressedBytes, page)\n  } else {\n    throw new Error(`parquet unsupported compression codec: ${codec}`)\n  }\n  if (page?.length !== uncompressed_page_size) {\n    throw new Error(`parquet decompressed page length ${page?.length} does not match header ${uncompressed_page_size}`)\n  }\n  return page\n}\n\n\n/**\n * Read a data page from the given Uint8Array.\n *\n * @param {Uint8Array} compressedBytes raw page data\n * @param {PageHeader} ph page header\n * @param {SchemaTree[]} schemaPath\n * @param {ColumnMetaData} columnMetadata\n * @param {Compressors | undefined} compressors\n * @returns {DataPage} definition levels, repetition levels, and array of values\n */\nexport function readDataPageV2(compressedBytes, ph, schemaPath, columnMetadata, compressors) {\n  const view = new DataView(compressedBytes.buffer, compressedBytes.byteOffset, compressedBytes.byteLength)\n  const reader = { view, offset: 0 }\n  const { codec, type } = columnMetadata\n  const daph2 = ph.data_page_header_v2\n  if (!daph2) throw new Error('parquet data page header v2 is undefined')\n\n  // repetition levels\n  const repetitionLevels = readRepetitionLevelsV2(reader, daph2, schemaPath)\n  reader.offset = daph2.repetition_levels_byte_length // readVarInt() => len for boolean v2?\n\n  // definition levels\n  const definitionLevels = readDefinitionLevelsV2(reader, daph2, schemaPath)\n  // assert(reader.offset === daph2.repetition_levels_byte_length + daph2.definition_levels_byte_length)\n\n  const uncompressedPageSize = ph.uncompressed_page_size - daph2.definition_levels_byte_length - daph2.repetition_levels_byte_length\n\n  let page = compressedBytes.subarray(reader.offset)\n  if (daph2.is_compressed !== false) {\n    page = decompressPage(page, uncompressedPageSize, codec, compressors)\n  }\n  const pageView = new DataView(page.buffer, page.byteOffset, page.byteLength)\n  const pageReader = { view: pageView, offset: 0 }\n\n  // read values based on encoding\n  /** @type {DecodedArray} */\n  let dataPage\n  const nValues = daph2.num_values - daph2.num_nulls\n  if (daph2.encoding === 'PLAIN') {\n    const { type_length } = schemaPath[schemaPath.length - 1].element\n    dataPage = readPlain(pageReader, type, nValues, type_length)\n  } else if (daph2.encoding === 'RLE') {\n    // assert(columnMetadata.type === 'BOOLEAN')\n    dataPage = new Array(nValues)\n    readRleBitPackedHybrid(pageReader, 1, 0, dataPage)\n    dataPage = dataPage.map(x => !!x)\n  } else if (\n    daph2.encoding === 'PLAIN_DICTIONARY' ||\n    daph2.encoding === 'RLE_DICTIONARY'\n  ) {\n    const bitWidth = pageView.getUint8(pageReader.offset++)\n    dataPage = new Array(nValues)\n    readRleBitPackedHybrid(pageReader, bitWidth, uncompressedPageSize - 1, dataPage)\n  } else if (daph2.encoding === 'DELTA_BINARY_PACKED') {\n    const int32 = type === 'INT32'\n    dataPage = int32 ? new Int32Array(nValues) : new BigInt64Array(nValues)\n    deltaBinaryUnpack(pageReader, nValues, dataPage)\n  } else if (daph2.encoding === 'DELTA_LENGTH_BYTE_ARRAY') {\n    dataPage = new Array(nValues)\n    deltaLengthByteArray(pageReader, nValues, dataPage)\n  } else if (daph2.encoding === 'DELTA_BYTE_ARRAY') {\n    dataPage = new Array(nValues)\n    deltaByteArray(pageReader, nValues, dataPage)\n  } else if (daph2.encoding === 'BYTE_STREAM_SPLIT') {\n    const { type_length } = schemaPath[schemaPath.length - 1].element\n    dataPage = byteStreamSplit(reader, nValues, type, type_length)\n  } else {\n    throw new Error(`parquet unsupported encoding: ${daph2.encoding}`)\n  }\n\n  return { definitionLevels, repetitionLevels, dataPage }\n}\n\n/**\n * @param {DataReader} reader\n * @param {DataPageHeaderV2} daph2 data page header v2\n * @param {SchemaTree[]} schemaPath\n * @returns {any[]} repetition levels\n */\nfunction readRepetitionLevelsV2(reader, daph2, schemaPath) {\n  const maxRepetitionLevel = getMaxRepetitionLevel(schemaPath)\n  if (!maxRepetitionLevel) return []\n\n  const values = new Array(daph2.num_values)\n  readRleBitPackedHybrid(\n    reader, bitWidth(maxRepetitionLevel), daph2.repetition_levels_byte_length, values\n  )\n  return values\n}\n\n/**\n * @param {DataReader} reader\n * @param {DataPageHeaderV2} daph2 data page header v2\n * @param {SchemaTree[]} schemaPath\n * @returns {number[] | undefined} definition levels\n */\nfunction readDefinitionLevelsV2(reader, daph2, schemaPath) {\n  const maxDefinitionLevel = getMaxDefinitionLevel(schemaPath)\n  if (maxDefinitionLevel) {\n    // V2 we know the length\n    const values = new Array(daph2.num_values)\n    readRleBitPackedHybrid(reader, bitWidth(maxDefinitionLevel), daph2.definition_levels_byte_length, values)\n    return values\n  }\n}\n","/**\n * Replace bigint, date, etc with legal JSON types.\n * When parsing parquet files, bigints are used to represent 64-bit integers.\n * However, JSON does not support bigints, so it's helpful to convert to numbers.\n *\n * @param {any} obj object to convert\n * @returns {unknown} converted object\n */\nexport function toJson(obj) {\n  if (obj === undefined) return null\n  if (typeof obj === 'bigint') return Number(obj)\n  if (Array.isArray(obj)) return obj.map(toJson)\n  if (obj instanceof Uint8Array) return Array.from(obj)\n  if (obj instanceof Date) return obj.toISOString()\n  if (obj instanceof Object) {\n    /** @type {Record<string, unknown>} */\n    const newObj = {}\n    for (const key of Object.keys(obj)) {\n      if (obj[key] === undefined) continue\n      newObj[key] = toJson(obj[key])\n    }\n    return newObj\n  }\n  return obj\n}\n\n/**\n * Concatenate two arrays fast.\n *\n * @param {any[]} aaa first array\n * @param {DecodedArray} bbb second array\n */\nexport function concat(aaa, bbb) {\n  const chunk = 10000\n  for (let i = 0; i < bbb.length; i += chunk) {\n    aaa.push(...bbb.slice(i, i + chunk))\n  }\n}\n\n/**\n * Get the byte length of a URL using a HEAD request.\n * If requestInit is provided, it will be passed to fetch.\n *\n * @param {string} url\n * @param {RequestInit} [requestInit] fetch options\n * @returns {Promise<number>}\n */\nexport async function byteLengthFromUrl(url, requestInit) {\n  return await fetch(url, { ...requestInit, method: 'HEAD' })\n    .then(res => {\n      if (!res.ok) throw new Error(`fetch head failed ${res.status}`)\n      const length = res.headers.get('Content-Length')\n      if (!length) throw new Error('missing content length')\n      return parseInt(length)\n    })\n}\n\n/**\n * Construct an AsyncBuffer for a URL.\n * If byteLength is not provided, will make a HEAD request to get the file size.\n * If requestInit is provided, it will be passed to fetch.\n *\n * @param {object} options\n * @param {string} options.url\n * @param {number} [options.byteLength]\n * @param {RequestInit} [options.requestInit]\n * @returns {Promise<AsyncBuffer>}\n */\nexport async function asyncBufferFromUrl({ url, byteLength, requestInit }) {\n  // byte length from HEAD request\n  byteLength ||= await byteLengthFromUrl(url, requestInit)\n  const init = requestInit || {}\n  return {\n    byteLength,\n    async slice(start, end) {\n      // fetch byte range from url\n      const headers = new Headers(init.headers)\n      const endStr = end === undefined ? '' : end - 1\n      headers.set('Range', `bytes=${start}-${endStr}`)\n      const res = await fetch(url, { ...init, headers })\n      if (!res.ok || !res.body) throw new Error(`fetch failed ${res.status}`)\n      return res.arrayBuffer()\n    },\n  }\n}\n\n/**\n * Construct an AsyncBuffer for a local file using node fs package.\n *\n * @param {string} filename\n * @returns {Promise<AsyncBuffer>}\n */\nexport async function asyncBufferFromFile(filename) {\n  const fsPackage = 'fs' // webpack no include\n  const fs = await import(fsPackage)\n  const stat = await fs.promises.stat(filename)\n  return {\n    byteLength: stat.size,\n    async slice(start, end) {\n      // read file slice\n      const readStream = fs.createReadStream(filename, { start, end })\n      return await readStreamToArrayBuffer(readStream)\n    },\n  }\n}\n\n/**\n * Convert a node ReadStream to ArrayBuffer.\n *\n * @param {import('stream').Readable} input\n * @returns {Promise<ArrayBuffer>}\n */\nfunction readStreamToArrayBuffer(input) {\n  return new Promise((resolve, reject) => {\n    /** @type {Buffer[]} */\n    const chunks = []\n    input.on('data', chunk => chunks.push(chunk))\n    input.on('end', () => {\n      const buffer = Buffer.concat(chunks)\n      resolve(buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength))\n    })\n    input.on('error', reject)\n  })\n}\n\n/**\n * Returns a cached layer on top of an AsyncBuffer. For caching slices of a file\n * that are read multiple times, possibly over a network.\n *\n * @param {AsyncBuffer} file file-like object to cache\n * @returns {AsyncBuffer} cached file-like object\n */\nexport function cachedAsyncBuffer({ byteLength, slice }) {\n  const cache = new Map()\n  return {\n    byteLength,\n    /**\n     * @param {number} start\n     * @param {number} [end]\n     * @returns {Awaitable<ArrayBuffer>}\n     */\n    slice(start, end) {\n      const key = cacheKey(start, end, byteLength)\n      const cached = cache.get(key)\n      if (cached) return cached\n      // cache miss, read from file\n      const promise = slice(start, end)\n      cache.set(key, promise)\n      return promise\n    },\n  }\n}\n\n\n/**\n * Returns canonical cache key for a byte range 'start,end'.\n * Normalize int-range and suffix-range requests to the same key.\n *\n * @import {AsyncBuffer, Awaitable, DecodedArray} from '../src/types.d.ts'\n * @param {number} start start byte of range\n * @param {number} [end] end byte of range, or undefined for suffix range\n * @param {number} [size] size of file, or undefined for suffix range\n * @returns {string}\n */\nfunction cacheKey(start, end, size) {\n  if (start < 0) {\n    if (end !== undefined) throw new Error(`invalid suffix range [${start}, ${end}]`)\n    if (size === undefined) return `${start},`\n    return `${size + start},${size}`\n  } else if (end !== undefined) {\n    if (start > end) throw new Error(`invalid empty range [${start}, ${end}]`)\n    return `${start},${end}`\n  } else if (size === undefined) {\n    return `${start},`\n  } else {\n    return `${start},${size}`\n  }\n}\n","import { assembleLists } from './assemble.js'\nimport { Encoding, PageType } from './constants.js'\nimport { convertWithDictionary } from './convert.js'\nimport { decompressPage, readDataPage, readDataPageV2, readDictionaryPage } from './datapage.js'\nimport { getMaxDefinitionLevel } from './schema.js'\nimport { deserializeTCompactProtocol } from './thrift.js'\nimport { concat } from './utils.js'\n\n/**\n * Parse column data from a buffer.\n *\n * @param {DataReader} reader\n * @param {number} rowLimit maximum number of rows to read\n * @param {ColumnMetaData} columnMetadata column metadata\n * @param {SchemaTree[]} schemaPath schema path for the column\n * @param {ParquetReadOptions} options read options\n * @returns {any[]} array of values\n */\nexport function readColumn(reader, rowLimit, columnMetadata, schemaPath, { compressors, utf8 }) {\n  const { element } = schemaPath[schemaPath.length - 1]\n  /** @type {DecodedArray | undefined} */\n  let dictionary = undefined\n  /** @type {any[]} */\n  const rowData = []\n\n  while (rowData.length < rowLimit) {\n    // parse column header\n    const header = parquetHeader(reader)\n    // assert(header.compressed_page_size !== undefined)\n\n    // read compressed_page_size bytes starting at offset\n    const compressedBytes = new Uint8Array(\n      reader.view.buffer, reader.view.byteOffset + reader.offset, header.compressed_page_size\n    )\n\n    // parse page data by type\n    /** @type {DecodedArray} */\n    let values\n    if (header.type === 'DATA_PAGE') {\n      const daph = header.data_page_header\n      if (!daph) throw new Error('parquet data page header is undefined')\n\n      const page = decompressPage(compressedBytes, Number(header.uncompressed_page_size), columnMetadata.codec, compressors)\n      const { definitionLevels, repetitionLevels, dataPage } = readDataPage(page, daph, schemaPath, columnMetadata)\n      // assert(!daph.statistics?.null_count || daph.statistics.null_count === BigInt(daph.num_values - dataPage.length))\n\n      // convert types, dereference dictionary, and assemble lists\n      values = convertWithDictionary(dataPage, dictionary, element, daph.encoding, utf8)\n      if (repetitionLevels.length || definitionLevels?.length) {\n        const maxDefinitionLevel = getMaxDefinitionLevel(schemaPath)\n        const repetitionPath = schemaPath.map(({ element }) => element.repetition_type)\n        assembleLists(\n          rowData, definitionLevels, repetitionLevels, values, repetitionPath, maxDefinitionLevel\n        )\n      } else {\n        // wrap nested flat data by depth\n        for (let i = 2; i < schemaPath.length; i++) {\n          if (schemaPath[i].element.repetition_type !== 'REQUIRED') {\n            values = Array.from(values, e => [e])\n          }\n        }\n        concat(rowData, values)\n      }\n    } else if (header.type === 'DATA_PAGE_V2') {\n      const daph2 = header.data_page_header_v2\n      if (!daph2) throw new Error('parquet data page header v2 is undefined')\n\n      const { definitionLevels, repetitionLevels, dataPage } = readDataPageV2(\n        compressedBytes, header, schemaPath, columnMetadata, compressors\n      )\n\n      // convert types, dereference dictionary, and assemble lists\n      values = convertWithDictionary(dataPage, dictionary, element, daph2.encoding, utf8)\n      if (repetitionLevels.length || definitionLevels?.length) {\n        const maxDefinitionLevel = getMaxDefinitionLevel(schemaPath)\n        const repetitionPath = schemaPath.map(({ element }) => element.repetition_type)\n        assembleLists(\n          rowData, definitionLevels, repetitionLevels, values, repetitionPath, maxDefinitionLevel\n        )\n      } else {\n        concat(rowData, values)\n      }\n    } else if (header.type === 'DICTIONARY_PAGE') {\n      const diph = header.dictionary_page_header\n      if (!diph) throw new Error('parquet dictionary page header is undefined')\n\n      const page = decompressPage(\n        compressedBytes, Number(header.uncompressed_page_size), columnMetadata.codec, compressors\n      )\n      dictionary = readDictionaryPage(page, diph, columnMetadata, element.type_length)\n    } else {\n      throw new Error(`parquet unsupported page type: ${header.type}`)\n    }\n    reader.offset += header.compressed_page_size\n  }\n  if (rowData.length < rowLimit) {\n    throw new Error(`parquet row data length ${rowData.length} does not match row group limit ${rowLimit}}`)\n  }\n  if (rowData.length > rowLimit) {\n    rowData.length = rowLimit // truncate to row limit\n  }\n  return rowData\n}\n\n/**\n * Find the start byte offset for a column chunk.\n *\n * @param {ColumnMetaData} columnMetadata\n * @returns {[bigint, bigint]} byte offset range\n */\nexport function getColumnRange({ dictionary_page_offset, data_page_offset, total_compressed_size }) {\n  let columnOffset = dictionary_page_offset\n  if (!columnOffset || data_page_offset < columnOffset) {\n    columnOffset = data_page_offset\n  }\n  return [columnOffset, columnOffset + total_compressed_size]\n}\n\n/**\n * Read parquet header from a buffer.\n *\n * @import {ColumnMetaData, DecodedArray, DataReader, PageHeader, ParquetReadOptions, SchemaTree} from '../src/types.d.ts'\n * @param {DataReader} reader - parquet file reader\n * @returns {PageHeader} metadata object and bytes read\n */\nfunction parquetHeader(reader) {\n  const header = deserializeTCompactProtocol(reader)\n\n  // Parse parquet header from thrift data\n  const type = PageType[header.field_1]\n  const uncompressed_page_size = header.field_2\n  const compressed_page_size = header.field_3\n  const crc = header.field_4\n  const data_page_header = header.field_5 && {\n    num_values: header.field_5.field_1,\n    encoding: Encoding[header.field_5.field_2],\n    definition_level_encoding: Encoding[header.field_5.field_3],\n    repetition_level_encoding: Encoding[header.field_5.field_4],\n    statistics: header.field_5.field_5 && {\n      max: header.field_5.field_5.field_1,\n      min: header.field_5.field_5.field_2,\n      null_count: header.field_5.field_5.field_3,\n      distinct_count: header.field_5.field_5.field_4,\n      max_value: header.field_5.field_5.field_5,\n      min_value: header.field_5.field_5.field_6,\n    },\n  }\n  const index_page_header = header.field_6\n  const dictionary_page_header = header.field_7 && {\n    num_values: header.field_7.field_1,\n    encoding: Encoding[header.field_7.field_2],\n    is_sorted: header.field_7.field_3,\n  }\n  const data_page_header_v2 = header.field_8 && {\n    num_values: header.field_8.field_1,\n    num_nulls: header.field_8.field_2,\n    num_rows: header.field_8.field_3,\n    encoding: Encoding[header.field_8.field_4],\n    definition_levels_byte_length: header.field_8.field_5,\n    repetition_levels_byte_length: header.field_8.field_6,\n    is_compressed: header.field_8.field_7 === undefined ? true : header.field_8.field_7, // default true\n    statistics: header.field_8.field_8,\n  }\n\n  return {\n    type,\n    uncompressed_page_size,\n    compressed_page_size,\n    crc,\n    data_page_header,\n    index_page_header,\n    dictionary_page_header,\n    data_page_header_v2,\n  }\n}\n","import { assembleNested } from './assemble.js'\nimport { getColumnRange, readColumn } from './column.js'\nimport { parquetMetadataAsync } from './metadata.js'\nimport { getSchemaPath } from './schema.js'\nimport { concat } from './utils.js'\n\n/**\n * Read parquet data rows from a file-like object.\n * Reads the minimal number of row groups and columns to satisfy the request.\n *\n * Returns a void promise when complete, and to throw errors.\n * Data is returned in onComplete, not the return promise, because\n * if onComplete is undefined, we parse the data, and emit chunks, but skip\n * computing the row view directly. This saves on allocation if the caller\n * wants to cache the full chunks, and make their own view of the data from\n * the chunks.\n *\n * @param {ParquetReadOptions} options read options\n * @returns {Promise<void>} resolves when all requested rows and columns are parsed\n */\nexport async function parquetRead(options) {\n  if (!options.file) throw new Error('parquet file is required')\n\n  // load metadata if not provided\n  options.metadata ||= await parquetMetadataAsync(options.file)\n  if (!options.metadata) throw new Error('parquet metadata not found')\n\n  const { metadata, onComplete, rowEnd } = options\n  const rowStart = options.rowStart || 0\n  /** @type {any[][]} */\n  const rowData = []\n\n  // find which row groups to read\n  let groupStart = 0 // first row index of the current group\n  for (const rowGroup of metadata.row_groups) {\n    // number of rows in this row group\n    const groupRows = Number(rowGroup.num_rows)\n    // if row group overlaps with row range, read it\n    if (groupStart + groupRows >= rowStart && (rowEnd === undefined || groupStart < rowEnd)) {\n      // read row group\n      const rowLimit = rowEnd && rowEnd - groupStart\n      const groupData = await readRowGroup(options, rowGroup, groupStart, rowLimit)\n      if (onComplete) {\n        // filter to rows in range\n        const start = Math.max(rowStart - groupStart, 0)\n        const end = rowEnd === undefined ? undefined : rowEnd - groupStart\n        concat(rowData, groupData.slice(start, end))\n      }\n    }\n    groupStart += groupRows\n  }\n\n  if (onComplete) onComplete(rowData)\n}\n\n/**\n * Read a row group from a file-like object.\n *\n * @param {ParquetReadOptions} options read options\n * @param {RowGroup} rowGroup row group to read\n * @param {number} groupStart row index of the first row in the group\n * @param {number} [rowLimit] max rows to read from this group\n * @returns {Promise<any[][]>} resolves to row data\n */\nexport async function readRowGroup(options, rowGroup, groupStart, rowLimit) {\n  const { file, metadata, columns } = options\n  if (!metadata) throw new Error('parquet metadata not found')\n  if (rowLimit === undefined || rowLimit > rowGroup.num_rows) rowLimit = Number(rowGroup.num_rows)\n\n  // loop through metadata to find min/max bytes to read\n  let [groupStartByte, groupEndByte] = [file.byteLength, 0]\n  rowGroup.columns.forEach(({ meta_data: columnMetadata }) => {\n    if (!columnMetadata) throw new Error('parquet column metadata is undefined')\n    // skip columns that are not requested\n    if (columns && !columns.includes(columnMetadata.path_in_schema[0])) return\n\n    const [columnStartByte, columnEndByte] = getColumnRange(columnMetadata).map(Number)\n    groupStartByte = Math.min(groupStartByte, columnStartByte)\n    groupEndByte = Math.max(groupEndByte, columnEndByte)\n  })\n  if (groupStartByte >= groupEndByte && columns?.length) {\n    // TODO: should throw if any column is missing\n    throw new Error(`parquet columns not found: ${columns.join(', ')}`)\n  }\n  // if row group size is less than 32mb, pre-load in one read\n  let groupBuffer\n  if (groupEndByte - groupStartByte <= 1 << 25) {\n    // pre-load row group byte data in one big read,\n    // otherwise read column data individually\n    groupBuffer = await file.slice(groupStartByte, groupEndByte)\n  }\n\n  const promises = []\n  // Top-level columns to assemble\n  const { children } = getSchemaPath(metadata.schema, [])[0]\n  const subcolumnNames = new Map(children.map(child => [child.element.name, getSubcolumns(child)]))\n  const subcolumnData = new Map() // columns to assemble as maps\n  // read column data\n  for (let columnIndex = 0; columnIndex < rowGroup.columns.length; columnIndex++) {\n    const columnMetadata = rowGroup.columns[columnIndex].meta_data\n    if (!columnMetadata) throw new Error('parquet column metadata is undefined')\n\n    // skip columns that are not requested\n    const columnName = columnMetadata.path_in_schema[0]\n    if (columns && !columns.includes(columnName)) continue\n\n    const [columnStartByte, columnEndByte] = getColumnRange(columnMetadata).map(Number)\n    const columnBytes = columnEndByte - columnStartByte\n\n    // skip columns larger than 1gb\n    // TODO: stream process the data, returning only the requested rows\n    if (columnBytes > 1 << 30) {\n      console.warn(`parquet skipping huge column \"${columnMetadata.path_in_schema}\" ${columnBytes.toLocaleString()} bytes`)\n      // TODO: set column to new Error('parquet column too large')\n      continue\n    }\n\n    // use pre-loaded row group byte data if available, else read column data\n    /** @type {Promise<ArrayBuffer>} */\n    let buffer\n    let bufferOffset = 0\n    if (groupBuffer) {\n      buffer = Promise.resolve(groupBuffer)\n      bufferOffset = columnStartByte - groupStartByte\n    } else {\n      // wrap awaitable to ensure it's a promise\n      buffer = Promise.resolve(file.slice(columnStartByte, columnEndByte))\n    }\n\n    // read column data async\n    promises.push(buffer.then(arrayBuffer => {\n      const schemaPath = getSchemaPath(metadata.schema, columnMetadata.path_in_schema)\n      const reader = { view: new DataView(arrayBuffer), offset: bufferOffset }\n      /** @type {any[] | undefined} */\n      let columnData = readColumn(reader, rowLimit, columnMetadata, schemaPath, options)\n      // assert(columnData.length === Number(rowGroup.num_rows)\n\n      // TODO: fast path for non-nested columns\n      // Save column data for assembly\n      const subcolumn = columnMetadata.path_in_schema.join('.')\n      subcolumnData.set(subcolumn, columnData)\n      columnData = undefined\n\n      const subcolumns = subcolumnNames.get(columnName)\n      if (subcolumns?.every(name => subcolumnData.has(name))) {\n        // We have all data needed to assemble a top level column\n        assembleNested(subcolumnData, schemaPath[1])\n        columnData = subcolumnData.get(columnName)\n        if (!columnData) {\n          throw new Error(`parquet column data not assembled: ${columnName}`)\n        }\n      }\n\n      // do not emit column data until structs are fully parsed\n      if (!columnData) return\n      // notify caller of column data\n      options.onChunk?.({\n        columnName,\n        columnData,\n        rowStart: groupStart,\n        rowEnd: groupStart + columnData.length,\n      })\n    }))\n  }\n  await Promise.all(promises)\n  if (options.onComplete) {\n    // transpose columns into rows\n    const groupData = new Array(rowLimit)\n    const includedColumnNames = children\n      .map(child => child.element.name)\n      .filter(name => !columns || columns.includes(name))\n    const columnOrder = columns || includedColumnNames\n    const includedColumns = columnOrder\n      .map(name => includedColumnNames.includes(name) ? subcolumnData.get(name) : undefined)\n\n    for (let row = 0; row < rowLimit; row++) {\n      if (options.rowFormat === 'object') {\n        // return each row as an object\n        /** @type {Record<string, any>} */\n        const rowData = {}\n        columnOrder.forEach((name, index) => {\n          rowData[name] = includedColumns[index]?.[row]\n        })\n        groupData[row] = rowData\n      } else {\n        // return each row as an array\n        groupData[row] = includedColumns.map(column => column?.[row])\n      }\n    }\n    return groupData\n  }\n  return []\n}\n\n\n/**\n * Return a list of sub-columns needed to construct a top-level column.\n *\n * @import {ParquetReadOptions, RowGroup, SchemaTree} from '../src/types.d.ts'\n * @param {SchemaTree} schema\n * @param {string[]} output\n * @returns {string[]}\n */\nfunction getSubcolumns(schema, output = []) {\n  if (schema.children.length) {\n    for (const child of schema.children) {\n      getSubcolumns(child, output)\n    }\n  } else {\n    output.push(schema.path.join('.'))\n  }\n  return output\n}\n","import { parquetReadObjects } from './hyparquet.js'\nimport { parquetMetadataAsync } from './metadata.js'\n\n/**\n * Wraps parquetRead with orderBy support.\n * This is a parquet-aware query engine that can read a subset of rows and columns.\n * Accepts an optional orderBy column name to sort the results.\n * Note that using orderBy may SIGNIFICANTLY increase the query time.\n *\n * @param {ParquetReadOptions & { orderBy?: string }} options\n * @returns {Promise<Record<string, any>[]>} resolves when all requested rows and columns are parsed\n */\nexport async function parquetQuery(options) {\n  const { file, rowStart, rowEnd, orderBy } = options\n  options.metadata ||= await parquetMetadataAsync(file)\n\n  // TODO: Faster path for: no orderBy, no rowStart/rowEnd, one row group\n\n  if (typeof orderBy === 'string') {\n    // Fetch orderBy column first\n    const orderColumn = await parquetReadObjects({ ...options, rowStart: undefined, rowEnd: undefined, columns: [orderBy] })\n\n    // Compute row groups to fetch\n    const sortedIndices = Array.from(orderColumn, (_, index) => index)\n      .sort((a, b) => compare(orderColumn[a][orderBy], orderColumn[b][orderBy]))\n      .slice(rowStart, rowEnd)\n\n    const sparseData = await parquetReadRows({ ...options, rows: sortedIndices })\n    const data = sortedIndices.map(index => sparseData[index])\n    return data\n  } else {\n    return await parquetReadObjects(options)\n  }\n}\n\n/**\n * Reads a list rows from a parquet file, reading only the row groups that contain the rows.\n * Returns a sparse array of rows.\n * @import {ParquetReadOptions} from '../src/types.d.ts'\n * @param {ParquetReadOptions & { rows: number[] }} options\n * @returns {Promise<Record<string, any>[]>}\n */\nasync function parquetReadRows(options) {\n  const { file, rows } = options\n  options.metadata ||= await parquetMetadataAsync(file)\n  const { row_groups: rowGroups } = options.metadata\n  // Compute row groups to fetch\n  const groupIncluded = Array(rowGroups.length).fill(false)\n  let groupStart = 0\n  const groupEnds = rowGroups.map(group => groupStart += Number(group.num_rows))\n  for (const index of rows) {\n    const groupIndex = groupEnds.findIndex(end => index < end)\n    groupIncluded[groupIndex] = true\n  }\n\n  // Compute row ranges to fetch\n  const rowRanges = []\n  let rangeStart\n  groupStart = 0\n  for (let i = 0; i < groupIncluded.length; i++) {\n    const groupEnd = groupStart + Number(rowGroups[i].num_rows)\n    if (groupIncluded[i]) {\n      if (rangeStart === undefined) {\n        rangeStart = groupStart\n      }\n    } else {\n      if (rangeStart !== undefined) {\n        rowRanges.push([rangeStart, groupEnd])\n        rangeStart = undefined\n      }\n    }\n    groupStart = groupEnd\n  }\n  if (rangeStart !== undefined) {\n    rowRanges.push([rangeStart, groupStart])\n  }\n\n  // Fetch by row group and map to rows\n  const sparseData = new Array(Number(options.metadata.num_rows))\n  for (const [rangeStart, rangeEnd] of rowRanges) {\n    // TODO: fetch in parallel\n    const groupData = await parquetReadObjects({ ...options, rowStart: rangeStart, rowEnd: rangeEnd })\n    for (let i = rangeStart; i < rangeEnd; i++) {\n      sparseData[i] = groupData[i - rangeStart]\n      sparseData[i].__index__ = i\n    }\n  }\n  return sparseData\n}\n\n/**\n * @param {any} a\n * @param {any} b\n * @returns {number}\n */\nfunction compare(a, b) {\n  if (a < b) return -1\n  if (a > b) return 1\n  return 1 // TODO: how to handle nulls?\n}\n","export { parquetMetadata, parquetMetadataAsync, parquetSchema } from './metadata.js'\n\nimport { parquetRead } from './read.js'\nexport { parquetRead }\n\nexport { parquetQuery } from './query.js'\n\nexport { snappyUncompress } from './snappy.js'\n\nexport { asyncBufferFromFile, asyncBufferFromUrl, byteLengthFromUrl, cachedAsyncBuffer, toJson } from './utils.js'\n\n/**\n * @param {ParquetReadOptions} options\n * @returns {Promise<Record<string, any>[]>} resolves when all requested rows and columns are parsed\n*/\nexport function parquetReadObjects(options) {\n  return new Promise((onComplete, reject) => {\n    parquetRead({\n      rowFormat: 'object',\n      ...options,\n      onComplete,\n    }).catch(reject)\n  })\n}\n/**\n * Explicitly export types for use in downstream typescript projects through\n * `import { ParquetReadOptions } from 'hyparquet'` for example.\n *\n * @template {any} T\n * @typedef {import('../src/types.d.ts').Awaitable<T>} Awaitable<T>\n */\n\n/**\n * @typedef {import('../src/types.d.ts').AsyncBuffer} AsyncBuffer\n * @typedef {import('../src/types.d.ts').DataReader} DataReader\n * @typedef {import('../src/types.d.ts').FileMetaData} FileMetaData\n * @typedef {import('../src/types.d.ts').SchemaTree} SchemaTree\n * @typedef {import('../src/types.d.ts').SchemaElement} SchemaElement\n * @typedef {import('../src/types.d.ts').ParquetType} ParquetType\n * @typedef {import('../src/types.d.ts').FieldRepetitionType} FieldRepetitionType\n * @typedef {import('../src/types.d.ts').ConvertedType} ConvertedType\n * @typedef {import('../src/types.d.ts').TimeUnit} TimeUnit\n * @typedef {import('../src/types.d.ts').LogicalType} LogicalType\n * @typedef {import('../src/types.d.ts').LogicalTypeType} LogicalTypeType\n * @typedef {import('../src/types.d.ts').RowGroup} RowGroup\n * @typedef {import('../src/types.d.ts').ColumnChunk} ColumnChunk\n * @typedef {import('../src/types.d.ts').ColumnMetaData} ColumnMetaData\n * @typedef {import('../src/types.d.ts').Encoding} Encoding\n * @typedef {import('../src/types.d.ts').CompressionCodec} CompressionCodec\n * @typedef {import('../src/types.d.ts').Compressors} Compressors\n * @typedef {import('../src/types.d.ts').Statistics} Statistics\n * @typedef {import('../src/types.d.ts').PageType} PageType\n * @typedef {import('../src/types.d.ts').PageHeader} PageHeader\n * @typedef {import('../src/types.d.ts').DataPageHeader} DataPageHeader\n * @typedef {import('../src/types.d.ts').DictionaryPageHeader} DictionaryPageHeader\n * @typedef {import('../src/types.d.ts').DecodedArray} DecodedArray\n * @typedef {import('../src/types.d.ts').OffsetIndex} OffsetIndex\n * @typedef {import('../src/types.d.ts').ColumnIndex} ColumnIndex\n * @typedef {import('../src/types.d.ts').BoundaryOrder} BoundaryOrder\n * @typedef {import('../src/types.d.ts').ColumnData} ColumnData\n * @typedef {import('../src/types.d.ts').ParquetReadOptions} ParquetReadOptions\n */\n","\nconst geometryTypePoint = 1\nconst geometryTypeLineString = 2\nconst geometryTypePolygon = 3\nconst geometryTypeMultiPoint = 4\nconst geometryTypeMultiLineString = 5\nconst geometryTypeMultiPolygon = 6\n\n/**\n * Minimal WKB (Well Known Binary) decoder supporting Polygon and MultiPolygon.\n * Supports both big-endian (byteOrder=0) and little-endian (byteOrder=1).\n * @import { Geometry } from './geojson.js'\n * @param {Uint8Array} wkb \n * @returns {Geometry} GeoJSON geometry object\n */\nexport function decodeWKB(wkb) {\n  let offset = 0\n\n  // Byte order: 0 = big-endian, 1 = little-endian\n  const byteOrder = wkb[offset]; offset += 1\n  const isLittleEndian = (byteOrder === 1)\n\n  // Helper functions\n  /**\n   * Read a 32-bit unsigned integer from buffer at given offset\n   * @param {Uint8Array} buf\n   * @param {number} off\n   */\n  function readUInt32(buf, off) {\n    const dv = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    return dv.getUint32(off, isLittleEndian)\n  }\n\n  /**\n   * Read a 64-bit double from buffer at given offset\n   * @param {Uint8Array} buf\n   * @param {number} off\n   */\n  function readDouble(buf, off) {\n    const dv = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    return dv.getFloat64(off, isLittleEndian)\n  }\n\n  // Read geometry type\n  const geometryType = readUInt32(wkb, offset)\n  offset += 4\n\n  // WKB geometry types (OGC):\n  if (geometryType === geometryTypePoint) {\n    // Point\n    const x = readDouble(wkb, offset); offset += 8\n    const y = readDouble(wkb, offset); offset += 8\n    return { type: 'Point', coordinates: [x,y] }\n  } else if (geometryType === geometryTypeLineString) {\n    // LineString\n    const numPoints = readUInt32(wkb, offset); offset += 4\n    const coords = []\n    for (let i = 0; i < numPoints; i++) {\n      const x = readDouble(wkb, offset); offset += 8\n      const y = readDouble(wkb, offset); offset += 8\n      coords.push([x,y])\n    }\n    return { type: 'LineString', coordinates: coords }\n  } else if (geometryType === geometryTypePolygon) {\n    // Polygon\n    const numRings = readUInt32(wkb, offset); offset += 4\n    const coords = []\n    for (let r = 0; r < numRings; r++) {\n      const numPoints = readUInt32(wkb, offset); offset += 4\n      const ring = []\n      for (let p = 0; p < numPoints; p++) {\n        const x = readDouble(wkb, offset); offset += 8\n        const y = readDouble(wkb, offset); offset += 8\n        ring.push([x,y])\n      }\n      coords.push(ring)\n    }\n    return { type: 'Polygon', coordinates: coords }\n\n  } else if (geometryType === geometryTypeMultiPolygon) {\n    // MultiPolygon\n    const numPolygons = readUInt32(wkb, offset); offset += 4\n    const polygons = []\n    for (let i = 0; i < numPolygons; i++) {\n      // Each polygon has its own byte order & geometry type\n      const pgByteOrder = wkb[offset]; offset += 1\n      const pgIsLittleEndian = (pgByteOrder === 1)\n      const pgType = (function() {\n        const dv = new DataView(wkb.buffer, wkb.byteOffset, wkb.byteLength)\n        const val = dv.getUint32(offset, pgIsLittleEndian)\n        offset += 4\n        return val\n      })()\n\n      if (pgType !== 3) throw new Error(`Expected Polygon in MultiPolygon, got ${pgType}`)\n\n      const numRings = (function() {\n        const dv = new DataView(wkb.buffer, wkb.byteOffset, wkb.byteLength)\n        const val = dv.getUint32(offset, pgIsLittleEndian)\n        offset += 4\n        return val\n      })()\n\n      const pgCoords = []\n      for (let r = 0; r < numRings; r++) {\n        const numPoints = (function() {\n          const dv = new DataView(wkb.buffer, wkb.byteOffset, wkb.byteLength)\n          const val = dv.getUint32(offset, pgIsLittleEndian)\n          offset += 4\n          return val\n        })()\n        const ring = []\n        for (let p = 0; p < numPoints; p++) {\n          const dv = new DataView(wkb.buffer, wkb.byteOffset, wkb.byteLength)\n          const x = dv.getFloat64(offset, pgIsLittleEndian); offset += 8\n          const y = dv.getFloat64(offset, pgIsLittleEndian); offset += 8\n          ring.push([x,y])\n        }\n        pgCoords.push(ring)\n      }\n      polygons.push(pgCoords)\n    }\n    return { type: 'MultiPolygon', coordinates: polygons }\n  } else {\n    throw new Error(\"Unsupported geometry type: \" + geometryType)\n  }\n}\n","import { parquetMetadataAsync, parquetQuery, toJson } from 'hyparquet'\nimport { decodeWKB } from './wkb.js'\n\n/**\n * @import { AsyncBuffer } from 'hyparquet'\n * @import { GeoJSON } from './geojson.js'\n * @param {AsyncBuffer} asyncBuffer \n * @returns {Promise<GeoJSON>}\n */\nexport async function geoparquet2geojson(asyncBuffer) {\n  const metadata = await parquetMetadataAsync(asyncBuffer)\n  const geoMetadata = metadata.key_value_metadata?.find(kv => kv.key === 'geo')\n  if (!geoMetadata) {\n    throw new Error('Invalid GeoParquet file: missing \"geo\" metadata')\n  }\n  const geoSchema = JSON.parse(geoMetadata.value || '{}')\n  console.log('Geoparquet schema:', geoSchema)\n\n  // Read all parquet data\n  const data = await parquetQuery({ file: asyncBuffer })\n  console.log('Geoparquet data:', toJson(data))\n\n  // Convert parquet data to GeoJSON\n  /**\n   * @import { Feature } from './geojson.js'\n   * @type {Feature[]}\n   */\n  const features = []\n\n  // According to the schema, the primary geometry column is 'geometry'\n  // We'll assume WKB encoding, and other columns are properties\n  const primaryColumn = geoSchema.primary_column || 'geometry'\n\n  for (const row of data) {\n    const wkbStr = row[primaryColumn]\n    if (!wkbStr) {\n      // No geometry\n      continue\n    }\n\n    // Convert the UTF-8 string with weird chars back to binary\n    // The parquetQuery returns strings. We'll treat as binary data with char codes.\n    const binary = new Uint8Array(wkbStr.length)\n    for (let i = 0; i < wkbStr.length; i++) {\n      binary[i] = wkbStr.charCodeAt(i)\n    }\n\n    // const geom2 = wkx.parse(binary.buffer)\n    // console.log('WKB:', binary, 'WKX:', geom2)\n\n    const geometry = decodeWKB(binary)\n\n    // Extract properties (all fields except geometry)\n    /** @type {Record<string, any>} */\n    const properties = {}\n    for (const key of Object.keys(row)) {\n      if (key !== primaryColumn) {\n        properties[key] = row[key]\n      }\n    }\n\n    /** @type {Feature} */\n    const feature = {\n      type: 'Feature',\n      geometry,\n      properties\n    }\n\n    features.push(feature)\n  }\n\n  return {\n    type: 'FeatureCollection',\n    features,\n  }\n}\n","import { asyncBufferFromUrl } from 'hyparquet'\nimport { geoparquet2geojson } from '../src/index.js'\n\nlet map\n\nwindow.initMap = async function loadGeoParquet() {\n  // Create a new map centered on a default location\n  const div = document.getElementById('map')\n  map = new google.maps.Map(div, {\n    center: { lat: 40.7128, lng: -74.0060 },\n    zoom: 5,\n  })\n\n  // URL or path to your GeoParquet file\n  const parquetUrl = 'examples/example.parquet'\n\n  try {\n    // Read the GeoParquet file and convert to GeoJSON\n    const asyncBuffer = await asyncBufferFromUrl({ url: parquetUrl })\n    const geojson = await geoparquet2geojson(asyncBuffer)\n\n    // Add the GeoJSON data to the map\n    map.data.addGeoJson(geojson)\n  } catch (error) {\n    console.error('Error loading or parsing GeoParquet file:', error)\n  }\n}\n"],"names":[],"mappings":"AAAA;AACO,MAAM,WAAW,GAAG;AAC3B,EAAE,SAAS;AACX,EAAE,OAAO;AACT,EAAE,OAAO;AACT,EAAE,OAAO;AACT,EAAE,OAAO;AACT,EAAE,QAAQ;AACV,EAAE,YAAY;AACd,EAAE,sBAAsB;AACxB;;AAEO,MAAM,QAAQ,GAAG;AACxB,EAAE,OAAO;AACT,EAAE,SAAS;AACX,EAAE,kBAAkB;AACpB,EAAE,KAAK;AACP,EAAE,YAAY;AACd,EAAE,qBAAqB;AACvB,EAAE,yBAAyB;AAC3B,EAAE,kBAAkB;AACpB,EAAE,gBAAgB;AAClB,EAAE,mBAAmB;AACrB;;AAEO,MAAM,mBAAmB,GAAG;AACnC,EAAE,UAAU;AACZ,EAAE,UAAU;AACZ,EAAE,UAAU;AACZ;;AAEA;AACO,MAAM,aAAa,GAAG;AAC7B,EAAE,MAAM;AACR,EAAE,KAAK;AACP,EAAE,eAAe;AACjB,EAAE,MAAM;AACR,EAAE,MAAM;AACR,EAAE,SAAS;AACX,EAAE,MAAM;AACR,EAAE,aAAa;AACf,EAAE,aAAa;AACf,EAAE,kBAAkB;AACpB,EAAE,kBAAkB;AACpB,EAAE,QAAQ;AACV,EAAE,SAAS;AACX,EAAE,SAAS;AACX,EAAE,SAAS;AACX,EAAE,OAAO;AACT,EAAE,QAAQ;AACV,EAAE,QAAQ;AACV,EAAE,QAAQ;AACV,EAAE,MAAM;AACR,EAAE,MAAM;AACR,EAAE,UAAU;AACZ;;AAqBO,MAAM,gBAAgB,GAAG;AAChC,EAAE,cAAc;AAChB,EAAE,QAAQ;AACV,EAAE,MAAM;AACR,EAAE,KAAK;AACP,EAAE,QAAQ;AACV,EAAE,KAAK;AACP,EAAE,MAAM;AACR,EAAE,SAAS;AACX;;AAEA;AACO,MAAM,QAAQ,GAAG;AACxB,EAAE,WAAW;AACb,EAAE,YAAY;AACd,EAAE,iBAAiB;AACnB,EAAE,cAAc;AAChB;;AC7FA,MAAM,SAAS,GAAG,SAAQ;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,qBAAqB,CAAC,IAAI,EAAE,UAAU,EAAE,aAAa,EAAE,QAAQ,EAAE,IAAI,GAAG,IAAI,EAAE;AAC9F,EAAE,IAAI,UAAU,IAAI,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;AACtD;AACA,IAAI,UAAU,GAAG,OAAO,CAAC,UAAU,EAAE,aAAa,EAAE,IAAI;AACxD,IAAI,IAAI,MAAM,GAAG;AACjB,IAAI,IAAI,IAAI,YAAY,UAAU,IAAI,EAAE,UAAU,YAAY,UAAU,CAAC,EAAE;AAC3E;AACA,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM;AACrD;AACA,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC1C,MAAM,MAAM,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;AACpC;AACA,IAAI,OAAO;AACX,GAAG,MAAM;AACT,IAAI,OAAO,OAAO,CAAC,IAAI,EAAE,aAAa,EAAE,IAAI;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,OAAO,CAAC,IAAI,EAAE,aAAa,EAAE,IAAI,GAAG,IAAI,EAAE;AAC1D,EAAE,MAAM,KAAK,GAAG,aAAa,CAAC;AAC9B,EAAE,IAAI,KAAK,KAAK,SAAS,EAAE;AAC3B,IAAI,MAAM,KAAK,GAAG,aAAa,CAAC,KAAK,IAAI;AACzC,IAAI,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,KAAK;AACtC,IAAI,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM;AACrC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACzC,MAAM,IAAI,IAAI,CAAC,CAAC,CAAC,YAAY,UAAU,EAAE;AACzC,QAAQ,GAAG,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG;AACzC,OAAO,MAAM;AACb,QAAQ,GAAG,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG;AACnC;AACA;AACA,IAAI,OAAO;AACX;AACA,EAAE,IAAI,KAAK,KAAK,SAAS,IAAI,aAAa,CAAC,IAAI,KAAK,OAAO,EAAE;AAC7D,IAAI,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,cAAc;AAC9C;AACA,EAAE,IAAI,KAAK,KAAK,MAAM,EAAE;AACxB,IAAI,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM;AACrC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACzC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,SAAS;AAC3C;AACA,IAAI,OAAO;AACX;AACA,EAAE,IAAI,KAAK,KAAK,kBAAkB,EAAE;AACpC,IAAI,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM;AACrC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACzC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACvC;AACA,IAAI,OAAO;AACX;AACA,EAAE,IAAI,KAAK,KAAK,kBAAkB,EAAE;AACpC,IAAI,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM;AACrC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACzC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;AAC/C;AACA,IAAI,OAAO;AACX;AACA,EAAE,IAAI,KAAK,KAAK,MAAM,EAAE;AACxB,IAAI,MAAM,OAAO,GAAG,IAAI,WAAW;AACnC,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACtD;AACA,EAAE,IAAI,KAAK,KAAK,MAAM,EAAE;AACxB,IAAI,MAAM,IAAI,KAAK,CAAC,4BAA4B;AAChD;AACA,EAAE,IAAI,KAAK,KAAK,UAAU,EAAE;AAC5B,IAAI,MAAM,IAAI,KAAK,CAAC,gCAAgC;AACpD;AACA,EAAE,IAAI,KAAK,KAAK,MAAM,IAAI,IAAI,IAAI,aAAa,CAAC,IAAI,KAAK,YAAY,EAAE;AACvE,IAAI,MAAM,OAAO,GAAG,IAAI,WAAW;AACnC,IAAI,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM;AACrC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACzC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAChD;AACA,IAAI,OAAO;AACX;AACA,EAAE,IAAI,KAAK,KAAK,SAAS,EAAE;AAC3B,IAAI,MAAM,GAAG,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,MAAM;AAC9C,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACzC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAC7B;AACA,IAAI,OAAO;AACX;AACA,EAAE,IAAI,aAAa,CAAC,YAAY,EAAE,IAAI,KAAK,SAAS,EAAE;AACtD,IAAI,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,YAAY;AAC5C;AACA,EAAE,IAAI,aAAa,CAAC,YAAY,EAAE,IAAI,KAAK,WAAW,EAAE;AACxD,IAAI,MAAM,EAAE,IAAI,EAAE,GAAG,aAAa,CAAC;AACnC,IAAI,IAAI,MAAM,GAAG;AACjB,IAAI,IAAI,IAAI,KAAK,QAAQ,EAAE,MAAM,GAAG;AACpC,IAAI,IAAI,IAAI,KAAK,OAAO,EAAE,MAAM,GAAG;AACnC,IAAI,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM;AACrC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACzC,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC;AAChD;AACA,IAAI,OAAO;AACX;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACO,SAAS,YAAY,CAAC,KAAK,EAAE;AACpC;AACA,EAAE,IAAI,KAAK,GAAG;AACd,EAAE,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;AAC5B,IAAI,KAAK,GAAG,KAAK,IAAI,CAAC,GAAG;AACzB;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS,cAAc,CAAC,KAAK,EAAE;AAC/B,EAAE,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,KAAK,IAAI,GAAG,IAAI,QAAQ;AAC/C,EAAE,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,KAAK,GAAG,mBAAmB,IAAI,QAAQ;AAC9D,EAAE,MAAM,MAAM,GAAG,IAAI,GAAG,SAAS,GAAG;AACpC,EAAE,OAAO,IAAI,IAAI,CAAC,MAAM;AACxB;;AAEA;AACA;AACA;AACA;AACO,SAAS,YAAY,CAAC,KAAK,EAAE;AACpC,EAAE,IAAI,CAAC,KAAK,EAAE,OAAO;AACrB,EAAE,MAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;AACvC,EAAE,MAAM,IAAI,GAAG,KAAK,IAAI,EAAE,GAAG,CAAC,CAAC,GAAG;AAClC,EAAE,MAAM,GAAG,GAAG,KAAK,IAAI,EAAE,GAAG;AAC5B,EAAE,MAAM,IAAI,GAAG,KAAK,GAAG;AACvB,EAAE,IAAI,GAAG,KAAK,CAAC,EAAE,OAAO,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,IAAI,GAAG,IAAI,CAAC;AAC/D,EAAE,IAAI,GAAG,KAAK,IAAI,EAAE,OAAO,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG;AAC/C,EAAE,OAAO,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,IAAI;AACxD;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,UAAU,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE;AAC7C,EAAE,MAAM,OAAO,GAAG,MAAM,CAAC,SAAS;AAClC,EAAE,MAAM,QAAQ,GAAG;AACnB,EAAE,IAAI,KAAK,GAAG;;AAEd;AACA,EAAE,IAAI,OAAO,CAAC,YAAY,EAAE;AAC5B,IAAI,OAAO,QAAQ,CAAC,MAAM,GAAG,OAAO,CAAC,YAAY,EAAE;AACnD,MAAM,MAAM,YAAY,GAAG,MAAM,CAAC,SAAS,GAAG,KAAK;AACnD,MAAM,MAAM,KAAK,GAAG,UAAU,CAAC,MAAM,EAAE,SAAS,GAAG,KAAK,EAAE,CAAC,GAAG,IAAI,EAAE,YAAY,CAAC,IAAI,CAAC;AACtF,MAAM,KAAK,IAAI,KAAK,CAAC;AACrB,MAAM,QAAQ,CAAC,IAAI,CAAC,KAAK;AACzB;AACA;;AAEA,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,IAAI;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,aAAa,CAAC,MAAM,EAAE,IAAI,EAAE;AAC5C,EAAE,IAAI,IAAI,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACrC,EAAE,MAAM,IAAI,GAAG,CAAC,IAAI;AACpB,EAAE,KAAK,MAAM,IAAI,IAAI,IAAI,EAAE;AAC3B,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,KAAK,IAAI;AACzE,IAAI,IAAI,CAAC,KAAK,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,kCAAkC,EAAE,IAAI,CAAC,CAAC;AAC3E,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK;AACnB,IAAI,IAAI,GAAG;AACX;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,qBAAqB,CAAC,UAAU,EAAE;AAClD,EAAE,IAAI,QAAQ,GAAG;AACjB,EAAE,KAAK,MAAM,EAAE,OAAO,EAAE,IAAI,UAAU,EAAE;AACxC,IAAI,IAAI,OAAO,CAAC,eAAe,KAAK,UAAU,EAAE;AAChD,MAAM,QAAQ;AACd;AACA;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,qBAAqB,CAAC,UAAU,EAAE;AAClD,EAAE,IAAI,QAAQ,GAAG;AACjB,EAAE,KAAK,MAAM,EAAE,OAAO,EAAE,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;AACjD,IAAI,IAAI,OAAO,CAAC,eAAe,KAAK,UAAU,EAAE;AAChD,MAAM,QAAQ;AACd;AACA;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,UAAU,CAAC,MAAM,EAAE;AACnC,EAAE,IAAI,CAAC,MAAM,EAAE,OAAO;AACtB,EAAE,IAAI,MAAM,CAAC,OAAO,CAAC,cAAc,KAAK,MAAM,EAAE,OAAO;AACvD,EAAE,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,OAAO;;AAEzC,EAAE,MAAM,UAAU,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AACtC,EAAE,IAAI,UAAU,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,OAAO;AAC7C,EAAE,IAAI,UAAU,CAAC,OAAO,CAAC,eAAe,KAAK,UAAU,EAAE,OAAO;;AAEhE,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,SAAS,CAAC,MAAM,EAAE;AAClC,EAAE,IAAI,CAAC,MAAM,EAAE,OAAO;AACtB,EAAE,IAAI,MAAM,CAAC,OAAO,CAAC,cAAc,KAAK,KAAK,EAAE,OAAO;AACtD,EAAE,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,OAAO;;AAEzC,EAAE,MAAM,UAAU,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AACtC,EAAE,IAAI,UAAU,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE,OAAO;AAC/C,EAAE,IAAI,UAAU,CAAC,OAAO,CAAC,eAAe,KAAK,UAAU,EAAE,OAAO;;AAEhE,EAAE,MAAM,QAAQ,GAAG,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,KAAK,KAAK;AACjF,EAAE,IAAI,QAAQ,EAAE,OAAO,CAAC,eAAe,KAAK,UAAU,EAAE,OAAO;;AAE/D,EAAE,MAAM,UAAU,GAAG,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,KAAK,OAAO;AACrF,EAAE,IAAI,UAAU,EAAE,OAAO,CAAC,eAAe,KAAK,UAAU,EAAE,OAAO;;AAEjE,EAAE,OAAO;AACT;;ACtHA;AACA,MAAM,WAAW,GAAG;AACpB,EAAE,IAAI,EAAE,CAAC;AACT,EAAE,IAAI,EAAE,CAAC;AACT,EAAE,KAAK,EAAE,CAAC;AACV,EAAE,IAAI,EAAE,CAAC;AACT,EAAE,GAAG,EAAE,CAAC;AACR,EAAE,GAAG,EAAE,CAAC;AACR,EAAE,GAAG,EAAE,CAAC;AACR,EAAE,MAAM,EAAE,CAAC;AACX,EAAE,MAAM,EAAE,CAAC;AACX,EAAE,IAAI,EAAE,CAAC;AACT,EAAE,GAAG,EAAE,EAAE;AACT,EAAE,GAAG,EAAE,EAAE;AACT,EAAE,MAAM,EAAE,EAAE;AACZ,EAAE,IAAI,EAAE,EAAE;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,2BAA2B,CAAC,MAAM,EAAE;AACpD,EAAE,IAAI,OAAO,GAAG;AAChB;AACA,EAAE,MAAM,KAAK,GAAG;;AAEhB,EAAE,OAAO,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,EAAE;AACjD;AACA,IAAI,MAAM,CAAC,IAAI,EAAE,GAAG,EAAE,UAAU,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,OAAO;AAClE,IAAI,OAAO,GAAG;;AAEd,IAAI,IAAI,IAAI,KAAK,WAAW,CAAC,IAAI,EAAE;AACnC,MAAM;AACN;;AAEA;AACA,IAAI,KAAK,CAAC,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,IAAI;AACpD;;AAEA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,WAAW,CAAC,MAAM,EAAE,IAAI,EAAE;AACnC,EAAE,QAAQ,IAAI;AACd,EAAE,KAAK,WAAW,CAAC,IAAI;AACvB,IAAI,OAAO;AACX,EAAE,KAAK,WAAW,CAAC,KAAK;AACxB,IAAI,OAAO;AACX,EAAE,KAAK,WAAW,CAAC,IAAI;AACvB;AACA,IAAI,OAAO,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE;AAC9C,EAAE,KAAK,WAAW,CAAC,GAAG;AACtB,EAAE,KAAK,WAAW,CAAC,GAAG;AACtB,IAAI,OAAO,UAAU,CAAC,MAAM;AAC5B,EAAE,KAAK,WAAW,CAAC,GAAG;AACtB,IAAI,OAAO,gBAAgB,CAAC,MAAM;AAClC,EAAE,KAAK,WAAW,CAAC,MAAM,EAAE;AAC3B,IAAI,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI;AAC5D,IAAI,MAAM,CAAC,MAAM,IAAI;AACrB,IAAI,OAAO;AACX;AACA,EAAE,KAAK,WAAW,CAAC,MAAM,EAAE;AAC3B,IAAI,MAAM,YAAY,GAAG,UAAU,CAAC,MAAM;AAC1C,IAAI,MAAM,QAAQ,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,YAAY;AAC5G,IAAI,MAAM,CAAC,MAAM,IAAI;AACrB,IAAI,OAAO;AACX;AACA,EAAE,KAAK,WAAW,CAAC,IAAI,EAAE;AACzB,IAAI,MAAM,CAAC,QAAQ,EAAE,QAAQ,CAAC,GAAG,mBAAmB,CAAC,MAAM;AAC3D,IAAI,MAAM,QAAQ,GAAG,QAAQ,KAAK,WAAW,CAAC,IAAI,IAAI,QAAQ,KAAK,WAAW,CAAC;AAC/E,IAAI,MAAM,MAAM,GAAG,IAAI,KAAK,CAAC,QAAQ;AACrC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE;AACvC,MAAM,MAAM,CAAC,CAAC,CAAC,GAAG,QAAQ,GAAG,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,QAAQ;AACvG;AACA,IAAI,OAAO;AACX;AACA,EAAE,KAAK,WAAW,CAAC,MAAM,EAAE;AAC3B;AACA,IAAI,MAAM,YAAY,GAAG;AACzB,IAAI,IAAI,aAAa,GAAG;AACxB,IAAI,OAAO,IAAI,EAAE;AACjB,MAAM,IAAI,eAAe,EAAE;AAC3B,MAAM,CAAC,eAAe,EAAE,SAAS,EAAE,aAAa,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,aAAa;AACxF,MAAM,IAAI,eAAe,KAAK,WAAW,CAAC,IAAI,EAAE;AAChD,QAAQ;AACR;AACA,MAAM,YAAY,CAAC,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,eAAe;AAC9E;AACA,IAAI,OAAO;AACX;AACA;AACA,EAAE,KAAK,WAAW,CAAC,IAAI,EAAE;AACzB;AACA,IAAI,IAAI,IAAI,GAAG;AACf,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;AACjC,MAAM,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG;AAChF;AACA,IAAI,OAAO;AACX;AACA,EAAE;AACF,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,uBAAuB,EAAE,IAAI,CAAC,CAAC;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,UAAU,CAAC,MAAM,EAAE;AACnC,EAAE,IAAI,MAAM,GAAG;AACf,EAAE,IAAI,KAAK,GAAG;AACd,EAAE,OAAO,IAAI,EAAE;AACf,IAAI,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE;AACrD,IAAI,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,KAAK;AAC/B,IAAI,IAAI,EAAE,IAAI,GAAG,IAAI,CAAC,EAAE;AACxB,MAAM,OAAO;AACb;AACA,IAAI,KAAK,IAAI;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,aAAa,CAAC,MAAM,EAAE;AAC/B,EAAE,IAAI,MAAM,GAAG;AACf,EAAE,IAAI,KAAK,GAAG;AACd,EAAE,OAAO,IAAI,EAAE;AACf,IAAI,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE;AACrD,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI;AACrC,IAAI,IAAI,EAAE,IAAI,GAAG,IAAI,CAAC,EAAE;AACxB,MAAM,OAAO;AACb;AACA,IAAI,KAAK,IAAI;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,UAAU,CAAC,MAAM,EAAE;AAC5B,EAAE,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM;AAClC;AACA,EAAE,OAAO,MAAM,KAAK,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,gBAAgB,CAAC,MAAM,EAAE;AACzC,EAAE,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM;AACrC;AACA,EAAE,OAAO,MAAM,IAAI,MAAM,CAAC,CAAC,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc,CAAC,IAAI,EAAE;AAC9B,EAAE,OAAO,IAAI,GAAG;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc,CAAC,MAAM,EAAE,OAAO,EAAE;AACzC,EAAE,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE;AACnD,EAAE,IAAI,CAAC,IAAI,GAAG,IAAI,MAAM,WAAW,CAAC,IAAI,EAAE;AAC1C;AACA,IAAI,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,OAAO;AACzB;AACA,EAAE,MAAM,KAAK,GAAG,IAAI,IAAI;AACxB,EAAE,IAAI,IAAG;AACT,EAAE,IAAI,KAAK,EAAE;AACb;AACA,IAAI,GAAG,GAAG,OAAO,GAAG;AACpB,GAAG,MAAM;AACT,IAAI,MAAM,IAAI,KAAK,CAAC,kCAAkC;AACtD;AACA,EAAE,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mBAAmB,CAAC,MAAM,EAAE;AACrC,EAAE,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE;AACvD,EAAE,MAAM,IAAI,GAAG,QAAQ,IAAI;AAC3B,EAAE,MAAM,IAAI,GAAG,cAAc,CAAC,QAAQ;AACtC,EAAE,IAAI,IAAI,KAAK,EAAE,EAAE;AACnB,IAAI,MAAM,OAAO,GAAG,UAAU,CAAC,MAAM;AACrC,IAAI,OAAO,CAAC,IAAI,EAAE,OAAO;AACzB;AACA,EAAE,OAAO,CAAC,IAAI,EAAE,IAAI;AACpB;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,oBAAoB,CAAC,WAAW,EAAE,gBAAgB,GAAG,CAAC,IAAI,EAAE,cAAc;AAChG,EAAE,IAAI,CAAC,WAAW,EAAE,MAAM,IAAI,KAAK,CAAC,0BAA0B;AAC9D,EAAE,IAAI,EAAE,WAAW,CAAC,UAAU,IAAI,CAAC,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,qCAAqC;;AAE3F;AACA,EAAE,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,WAAW,CAAC,UAAU,GAAG,gBAAgB;AAC5E,EAAE,MAAM,YAAY,GAAG,MAAM,WAAW,CAAC,KAAK,CAAC,YAAY,EAAE,WAAW,CAAC,UAAU;;AAEnF;AACA,EAAE,MAAM,UAAU,GAAG,IAAI,QAAQ,CAAC,YAAY;AAC9C,EAAE,IAAI,UAAU,CAAC,SAAS,CAAC,YAAY,CAAC,UAAU,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,UAAU,EAAE;AAC9E,IAAI,MAAM,IAAI,KAAK,CAAC,uCAAuC;AAC3D;;AAEA;AACA;AACA,EAAE,MAAM,cAAc,GAAG,UAAU,CAAC,SAAS,CAAC,YAAY,CAAC,UAAU,GAAG,CAAC,EAAE,IAAI;AAC/E,EAAE,IAAI,cAAc,GAAG,WAAW,CAAC,UAAU,GAAG,CAAC,EAAE;AACnD,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,wBAAwB,EAAE,cAAc,CAAC,0BAA0B,EAAE,WAAW,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;AACtH;;AAEA;AACA,EAAE,IAAI,cAAc,GAAG,CAAC,GAAG,gBAAgB,EAAE;AAC7C;AACA,IAAI,MAAM,cAAc,GAAG,WAAW,CAAC,UAAU,GAAG,cAAc,GAAG;AACrE,IAAI,MAAM,cAAc,GAAG,MAAM,WAAW,CAAC,KAAK,CAAC,cAAc,EAAE,YAAY;AAC/E;AACA,IAAI,MAAM,cAAc,GAAG,IAAI,WAAW,CAAC,cAAc,GAAG,CAAC;AAC7D,IAAI,MAAM,YAAY,GAAG,IAAI,UAAU,CAAC,cAAc;AACtD,IAAI,YAAY,CAAC,GAAG,CAAC,IAAI,UAAU,CAAC,cAAc,CAAC;AACnD,IAAI,YAAY,CAAC,GAAG,CAAC,IAAI,UAAU,CAAC,YAAY,CAAC,EAAE,YAAY,GAAG,cAAc;AAChF,IAAI,OAAO,eAAe,CAAC,cAAc;AACzC,GAAG,MAAM;AACT;AACA,IAAI,OAAO,eAAe,CAAC,YAAY;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,eAAe,CAAC,WAAW,EAAE;AAC7C,EAAE,IAAI,CAAC,WAAW,EAAE,MAAM,IAAI,KAAK,CAAC,0BAA0B;AAC9D,EAAE,MAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,WAAW;;AAEvC;AACA,EAAE,IAAI,IAAI,CAAC,UAAU,GAAG,CAAC,EAAE;AAC3B,IAAI,MAAM,IAAI,KAAK,CAAC,2BAA2B;AAC/C;AACA,EAAE,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,UAAU,EAAE;AAChE,IAAI,MAAM,IAAI,KAAK,CAAC,uCAAuC;AAC3D;;AAEA;AACA;AACA,EAAE,MAAM,oBAAoB,GAAG,IAAI,CAAC,UAAU,GAAG;AACjD,EAAE,MAAM,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,oBAAoB,EAAE,IAAI;AAClE,EAAE,IAAI,cAAc,GAAG,IAAI,CAAC,UAAU,GAAG,CAAC,EAAE;AAC5C;AACA,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,wBAAwB,EAAE,cAAc,CAAC,0BAA0B,EAAE,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;AAC/G;;AAEA,EAAE,MAAM,cAAc,GAAG,oBAAoB,GAAG;AAChD,EAAE,MAAM,MAAM,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,cAAc;AAC/C,EAAE,MAAM,QAAQ,GAAG,2BAA2B,CAAC,MAAM;AACrD,EAAE,MAAM,OAAO,GAAG,IAAI,WAAW;AACjC,EAAE,SAAS,MAAM,2BAA2B,KAAK,EAAE;AACnD,IAAI,OAAO,KAAK,IAAI,OAAO,CAAC,MAAM,CAAC,KAAK;AACxC;;AAEA;AACA,EAAE,MAAM,OAAO,GAAG,QAAQ,CAAC;AAC3B;AACA,EAAE,MAAM,MAAM,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,oBAAoB,KAAK,MAAM;AACrE,IAAI,IAAI,EAAE,WAAW,CAAC,KAAK,CAAC,OAAO,CAAC;AACpC,IAAI,WAAW,EAAE,KAAK,CAAC,OAAO;AAC9B,IAAI,eAAe,EAAE,mBAAmB,CAAC,KAAK,CAAC,OAAO,CAAC;AACvD,IAAI,IAAI,EAAE,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC;AAC/B,IAAI,YAAY,EAAE,KAAK,CAAC,OAAO;AAC/B,IAAI,cAAc,EAAE,aAAa,CAAC,KAAK,CAAC,OAAO,CAAC;AAChD,IAAI,KAAK,EAAE,KAAK,CAAC,OAAO;AACxB,IAAI,SAAS,EAAE,KAAK,CAAC,OAAO;AAC5B,IAAI,QAAQ,EAAE,KAAK,CAAC,OAAO;AAC3B,IAAI,YAAY,EAAE,WAAW,CAAC,KAAK,CAAC,QAAQ,CAAC;AAC7C,GAAG,CAAC;AACJ;AACA,EAAE,MAAM,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI;AAChD,EAAE,MAAM,QAAQ,GAAG,QAAQ,CAAC;AAC5B,EAAE,MAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,oBAAoB,QAAQ,MAAM;AAC5E,IAAI,OAAO,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,oBAAoB,MAAM,wBAAwB,WAAW,MAAM;AACrG,MAAM,SAAS,EAAE,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC;AACvC,MAAM,WAAW,EAAE,MAAM,CAAC,OAAO;AACjC,MAAM,SAAS,EAAE,MAAM,CAAC,OAAO,IAAI;AACnC,QAAQ,IAAI,EAAE,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC;AACjD,QAAQ,SAAS,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC,uBAAuB,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC;AACxF,QAAQ,cAAc,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;AAC1D,QAAQ,KAAK,EAAE,gBAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC;AACvD,QAAQ,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AAC1C,QAAQ,uBAAuB,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AACvD,QAAQ,qBAAqB,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AACrD,QAAQ,kBAAkB,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AAClD,QAAQ,gBAAgB,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AAChD,QAAQ,iBAAiB,EAAE,MAAM,CAAC,OAAO,CAAC,QAAQ;AAClD,QAAQ,sBAAsB,EAAE,MAAM,CAAC,OAAO,CAAC,QAAQ;AACvD,QAAQ,UAAU,EAAE,YAAY,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC;AACpF,QAAQ,cAAc,EAAE,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,GAAG,CAAC,oBAAoB,YAAY,MAAM;AAC3F,UAAU,SAAS,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC;AACnD,UAAU,QAAQ,EAAE,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC;AAClD,UAAU,KAAK,EAAE,YAAY,CAAC,OAAO;AACrC,SAAS,CAAC,CAAC;AACX,QAAQ,mBAAmB,EAAE,MAAM,CAAC,OAAO,CAAC,QAAQ;AACpD,QAAQ,mBAAmB,EAAE,MAAM,CAAC,OAAO,CAAC,QAAQ;AACpD,QAAQ,eAAe,EAAE,MAAM,CAAC,OAAO,CAAC,QAAQ,IAAI;AACpD,UAAU,+BAA+B,EAAE,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,OAAO;AAC1E,UAAU,0BAA0B,EAAE,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,OAAO;AACrE,UAAU,0BAA0B,EAAE,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,OAAO;AACrE,SAAS;AACT,OAAO;AACP,MAAM,mBAAmB,EAAE,MAAM,CAAC,OAAO;AACzC,MAAM,mBAAmB,EAAE,MAAM,CAAC,OAAO;AACzC,MAAM,mBAAmB,EAAE,MAAM,CAAC,OAAO;AACzC,MAAM,mBAAmB,EAAE,MAAM,CAAC,OAAO;AACzC,MAAM,eAAe,EAAE,MAAM,CAAC,OAAO;AACrC,MAAM,yBAAyB,EAAE,MAAM,CAAC,OAAO;AAC/C,KAAK,CAAC,CAAC;AACP,IAAI,eAAe,EAAE,QAAQ,CAAC,OAAO;AACrC,IAAI,QAAQ,EAAE,QAAQ,CAAC,OAAO;AAC9B,IAAI,eAAe,EAAE,QAAQ,CAAC,OAAO,EAAE,GAAG,CAAC,oBAAoB,aAAa,MAAM;AAClF,MAAM,UAAU,EAAE,aAAa,CAAC,OAAO;AACvC,MAAM,UAAU,EAAE,aAAa,CAAC,OAAO;AACvC,MAAM,WAAW,EAAE,aAAa,CAAC,OAAO;AACxC,KAAK,CAAC,CAAC;AACP,IAAI,WAAW,EAAE,QAAQ,CAAC,OAAO;AACjC,IAAI,qBAAqB,EAAE,QAAQ,CAAC,OAAO;AAC3C,IAAI,OAAO,EAAE,QAAQ,CAAC,OAAO;AAC7B,GAAG,CAAC;AACJ,EAAE,MAAM,kBAAkB,GAAG,QAAQ,CAAC,OAAO,EAAE,GAAG,CAAC,oBAAoB,QAAQ,MAAM;AACrF,IAAI,GAAG,EAAE,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC;AACjC,IAAI,KAAK,EAAE,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC;AACnC,GAAG,CAAC;AACJ,EAAE,MAAM,UAAU,GAAG,MAAM,CAAC,QAAQ,CAAC,OAAO;;AAE5C,EAAE,OAAO;AACT,IAAI,OAAO;AACX,IAAI,MAAM;AACV,IAAI,QAAQ;AACZ,IAAI,UAAU;AACd,IAAI,kBAAkB;AACtB,IAAI,UAAU;AACd,IAAI,eAAe,EAAE,cAAc;AACnC;AACA;;AAYA;AACA;AACA;AACA;AACA,SAAS,WAAW,CAAC,WAAW,EAAE;AAClC,EAAE,IAAI,WAAW,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ;AACnD,EAAE,IAAI,WAAW,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,KAAK;AAChD,EAAE,IAAI,WAAW,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM;AACjD,EAAE,IAAI,WAAW,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM;AACjD,EAAE,IAAI,WAAW,EAAE,OAAO,EAAE,OAAO;AACnC,IAAI,IAAI,EAAE,SAAS;AACnB,IAAI,KAAK,EAAE,WAAW,CAAC,OAAO,CAAC,OAAO;AACtC,IAAI,SAAS,EAAE,WAAW,CAAC,OAAO,CAAC,OAAO;AAC1C;AACA,EAAE,IAAI,WAAW,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM;AACjD,EAAE,IAAI,WAAW,EAAE,OAAO,EAAE,OAAO;AACnC,IAAI,IAAI,EAAE,MAAM;AAChB,IAAI,eAAe,EAAE,WAAW,CAAC,OAAO,CAAC,OAAO;AAChD,IAAI,IAAI,EAAE,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC;AAC/C;AACA,EAAE,IAAI,WAAW,EAAE,OAAO,EAAE,OAAO;AACnC,IAAI,IAAI,EAAE,WAAW;AACrB,IAAI,eAAe,EAAE,WAAW,CAAC,OAAO,CAAC,OAAO;AAChD,IAAI,IAAI,EAAE,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC;AAC/C;AACA,EAAE,IAAI,WAAW,EAAE,QAAQ,EAAE,OAAO;AACpC,IAAI,IAAI,EAAE,SAAS;AACnB,IAAI,QAAQ,EAAE,WAAW,CAAC,QAAQ,CAAC,OAAO;AAC1C,IAAI,QAAQ,EAAE,WAAW,CAAC,QAAQ,CAAC,OAAO;AAC1C;AACA,EAAE,IAAI,WAAW,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM;AAClD,EAAE,IAAI,WAAW,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM;AAClD,EAAE,IAAI,WAAW,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM;AAClD,EAAE,IAAI,WAAW,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM;AAClD,EAAE,IAAI,WAAW,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS;AACrD,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS,QAAQ,CAAC,IAAI,EAAE;AACxB,EAAE,IAAI,IAAI,CAAC,OAAO,EAAE,OAAO;AAC3B,EAAE,IAAI,IAAI,CAAC,OAAO,EAAE,OAAO;AAC3B,EAAE,IAAI,IAAI,CAAC,OAAO,EAAE,OAAO;AAC3B,EAAE,MAAM,IAAI,KAAK,CAAC,4BAA4B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,YAAY,CAAC,KAAK,EAAE,MAAM,EAAE;AACrC,EAAE,OAAO,KAAK,IAAI;AAClB,IAAI,GAAG,EAAE,eAAe,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC;AAC/C,IAAI,GAAG,EAAE,eAAe,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC;AAC/C,IAAI,UAAU,EAAE,KAAK,CAAC,OAAO;AAC7B,IAAI,cAAc,EAAE,KAAK,CAAC,OAAO;AACjC,IAAI,SAAS,EAAE,eAAe,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC;AACrD,IAAI,SAAS,EAAE,eAAe,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC;AACrD,IAAI,kBAAkB,EAAE,KAAK,CAAC,OAAO;AACrC,IAAI,kBAAkB,EAAE,KAAK,CAAC,OAAO;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO,SAAS,eAAe,CAAC,KAAK,EAAE,MAAM,EAAE;AAC/C,EAAE,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,YAAY,EAAE,GAAG;AACjD,EAAE,IAAI,KAAK,KAAK,SAAS,EAAE,OAAO;AAClC,EAAE,IAAI,IAAI,KAAK,SAAS,EAAE,OAAO,KAAK,CAAC,CAAC,CAAC,KAAK;AAC9C,EAAE,IAAI,IAAI,KAAK,YAAY,EAAE,OAAO,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,KAAK;AAClE,EAAE,MAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU;AAC5E,EAAE,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,UAAU,KAAK,CAAC,EAAE,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI;AAC/E,EAAE,IAAI,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,UAAU,KAAK,CAAC,EAAE,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI;AAChF,EAAE,IAAI,IAAI,KAAK,OAAO,IAAI,cAAc,KAAK,MAAM,EAAE,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,QAAQ;AACtG,EAAE,IAAI,IAAI,KAAK,OAAO,IAAI,cAAc,KAAK,kBAAkB,EAAE,OAAO,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,KAAK,CAAC;AAC1H,EAAE,IAAI,IAAI,KAAK,OAAO,IAAI,cAAc,KAAK,kBAAkB,EAAE,OAAO,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;AAClH,EAAE,IAAI,IAAI,KAAK,OAAO,IAAI,YAAY,EAAE,IAAI,KAAK,WAAW,IAAI,YAAY,EAAE,IAAI,KAAK,OAAO,EAAE,OAAO,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,QAAQ,CAAC;AAC5J,EAAE,IAAI,IAAI,KAAK,OAAO,IAAI,YAAY,EAAE,IAAI,KAAK,WAAW,IAAI,YAAY,EAAE,IAAI,KAAK,QAAQ,EAAE,OAAO,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,KAAK,CAAC;AAC1J,EAAE,IAAI,IAAI,KAAK,OAAO,IAAI,YAAY,EAAE,IAAI,KAAK,WAAW,EAAE,OAAO,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;AAC/G,EAAE,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,UAAU,KAAK,CAAC,EAAE,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI;AAC7E,EAAE,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,UAAU,KAAK,CAAC,EAAE,OAAO,IAAI,CAAC,WAAW,CAAC,CAAC,EAAE,IAAI;AAChF,EAAE,IAAI,cAAc,KAAK,SAAS,EAAE,OAAO,YAAY,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,MAAM,CAAC,KAAK,IAAI,CAAC,CAAC;AAClG,EAAE,IAAI,YAAY,EAAE,IAAI,KAAK,SAAS,EAAE,OAAO,YAAY,CAAC,KAAK;AACjE,EAAE,IAAI,IAAI,KAAK,sBAAsB,EAAE,OAAO;AAC9C;AACA,EAAE,OAAO;AACT;;ACjSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,aAAa;AAC7B,EAAE,MAAM,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,MAAM,EAAE,cAAc,EAAE;AACtE,EAAE;AACF,EAAE,MAAM,CAAC,GAAG,gBAAgB,EAAE,MAAM,IAAI,gBAAgB,CAAC;AACzD,EAAE,IAAI,UAAU,GAAG;;AAEnB;AACA,EAAE,MAAM,cAAc,GAAG,CAAC,MAAM;AAChC,EAAE,IAAI,gBAAgB,GAAG;AACzB,EAAE,IAAI,YAAY,GAAG,EAAC;AACtB,EAAE,IAAI,eAAe,GAAG,EAAC;AACzB,EAAE,IAAI,eAAe,GAAG;;AAExB,EAAE,IAAI,gBAAgB,CAAC,CAAC,CAAC,EAAE;AAC3B;AACA,IAAI,OAAO,YAAY,GAAG,cAAc,CAAC,MAAM,GAAG,CAAC,IAAI,eAAe,GAAG,gBAAgB,CAAC,CAAC,CAAC,EAAE;AAC9F;AACA,MAAM,gBAAgB,GAAG,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC;AAC/C,MAAM,cAAc,CAAC,IAAI,CAAC,gBAAgB;AAC1C,MAAM,YAAY;AAClB,MAAM,IAAI,cAAc,CAAC,YAAY,CAAC,KAAK,UAAU,EAAE,eAAe;AACtE,MAAM,IAAI,cAAc,CAAC,YAAY,CAAC,KAAK,UAAU,EAAE,eAAe;AACtE;AACA;;AAEA,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;AAC9B;AACA,IAAI,MAAM,GAAG,GAAG,gBAAgB,EAAE,MAAM,GAAG,gBAAgB,CAAC,CAAC,CAAC,GAAG;AACjE,IAAI,MAAM,GAAG,GAAG,gBAAgB,CAAC,CAAC;;AAElC;AACA,IAAI,OAAO,YAAY,KAAK,GAAG,GAAG,eAAe,IAAI,cAAc,CAAC,YAAY,CAAC,KAAK,UAAU,CAAC,EAAE;AACnG,MAAM,IAAI,cAAc,CAAC,YAAY,CAAC,KAAK,UAAU,EAAE;AACvD,QAAQ,cAAc,CAAC,GAAG;AAC1B,QAAQ,eAAe;AACvB;AACA,MAAM,IAAI,cAAc,CAAC,YAAY,CAAC,KAAK,UAAU,EAAE,eAAe;AACtE,MAAM,YAAY;AAClB;AACA;AACA,IAAI,gBAAgB,GAAG,cAAc,CAAC,EAAE,CAAC,CAAC,CAAC;;AAE3C;AACA,IAAI;AACJ,MAAM,CAAC,YAAY,GAAG,cAAc,CAAC,MAAM,GAAG,CAAC,IAAI,cAAc,CAAC,YAAY,GAAG,CAAC,CAAC,KAAK,UAAU;AAClG,OAAO,eAAe,GAAG,GAAG,IAAI,cAAc,CAAC,YAAY,GAAG,CAAC,CAAC,KAAK,UAAU;AAC/E,MAAM;AACN,MAAM,YAAY;AAClB,MAAM,IAAI,cAAc,CAAC,YAAY,CAAC,KAAK,UAAU,EAAE;AACvD;AACA,QAAQ,MAAM,OAAO,GAAG;AACxB,QAAQ,gBAAgB,CAAC,IAAI,CAAC,OAAO;AACrC,QAAQ,gBAAgB,GAAG;AAC3B,QAAQ,cAAc,CAAC,IAAI,CAAC,OAAO;AACnC,QAAQ,eAAe;AACvB;AACA,MAAM,IAAI,cAAc,CAAC,YAAY,CAAC,KAAK,UAAU,EAAE,eAAe;AACtE;;AAEA;AACA,IAAI,IAAI,GAAG,KAAK,kBAAkB,EAAE;AACpC;AACA,MAAM,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC;AAChD,KAAK,MAAM,IAAI,YAAY,KAAK,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;AAC3D,MAAM,gBAAgB,CAAC,IAAI,CAAC,IAAI;AAChC,KAAK,MAAM;AACX,MAAM,gBAAgB,CAAC,IAAI,CAAC,EAAE;AAC9B;AACA;;AAEA;AACA,EAAE,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;AACtB;AACA,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,kBAAkB,EAAE,CAAC,EAAE,EAAE;AACjD;AACA,MAAM,MAAM,OAAO,GAAG;AACtB,MAAM,gBAAgB,CAAC,IAAI,CAAC,OAAO;AACnC,MAAM,gBAAgB,GAAG;AACzB;AACA;;AAEA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,cAAc,CAAC,aAAa,EAAE,MAAM,EAAE,KAAK,GAAG,CAAC,EAAE;AACjE,EAAE,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG;AACnC,EAAE,MAAM,QAAQ,GAAG,MAAM,CAAC,OAAO,CAAC,eAAe,KAAK;AACtD,EAAE,MAAM,SAAS,GAAG,QAAQ,GAAG,KAAK,GAAG,CAAC,GAAG;;AAE3C,EAAE,IAAI,UAAU,CAAC,MAAM,CAAC,EAAE;AAC1B,IAAI,IAAI,OAAO,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AACnC,IAAI,IAAI,QAAQ,GAAG;AACnB,IAAI,IAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;AACvC,MAAM,OAAO,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;AAClC,MAAM,QAAQ;AACd;AACA,IAAI,cAAc,CAAC,aAAa,EAAE,OAAO,EAAE,QAAQ;;AAEnD,IAAI,MAAM,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG;AAC3C,IAAI,MAAM,MAAM,GAAG,aAAa,CAAC,GAAG,CAAC,SAAS;AAC9C,IAAI,IAAI,CAAC,MAAM,EAAE,MAAM,IAAI,KAAK,CAAC,oCAAoC;AACrE,IAAI,IAAI,QAAQ,EAAE,cAAc,CAAC,MAAM,EAAE,KAAK;AAC9C,IAAI,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM;AAClC,IAAI,aAAa,CAAC,MAAM,CAAC,SAAS;AAClC,IAAI;AACJ;;AAEA,EAAE,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE;AACzB,IAAI,MAAM,OAAO,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;;AAE/C;AACA,IAAI,cAAc,CAAC,aAAa,EAAE,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,SAAS,GAAG,CAAC;AAC/E,IAAI,cAAc,CAAC,aAAa,EAAE,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,SAAS,GAAG,CAAC;;AAE/E,IAAI,MAAM,IAAI,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC;AAC3D,IAAI,MAAM,MAAM,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,CAAC;;AAE/D,IAAI,IAAI,CAAC,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,iCAAiC;AAChE,IAAI,IAAI,CAAC,MAAM,EAAE,MAAM,IAAI,KAAK,CAAC,mCAAmC;AACpE,IAAI,IAAI,IAAI,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,EAAE;AACvC,MAAM,MAAM,IAAI,KAAK,CAAC,8CAA8C;AACpE;;AAEA,IAAI,MAAM,GAAG,GAAG,YAAY,CAAC,IAAI,EAAE,MAAM,EAAE,SAAS;AACpD,IAAI,IAAI,QAAQ,EAAE,cAAc,CAAC,GAAG,EAAE,KAAK;;AAE3C,IAAI,aAAa,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC;AACjD,IAAI,aAAa,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,CAAC;AACnD,IAAI,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG;AAC/B,IAAI;AACJ;;AAEA;AACA,EAAE,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;AAC9B;AACA,IAAI,MAAM,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,eAAe,KAAK,UAAU,GAAG,KAAK,GAAG,KAAK,GAAG;AACxF;AACA,IAAI,MAAM,MAAM,GAAG;AACnB,IAAI,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,QAAQ,EAAE;AACzC,MAAM,cAAc,CAAC,aAAa,EAAE,KAAK,EAAE,WAAW;AACtD,MAAM,MAAM,SAAS,GAAG,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;AAC9D,MAAM,IAAI,CAAC,SAAS,EAAE,MAAM,IAAI,KAAK,CAAC,mCAAmC;AACzE,MAAM,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG;AACnC;AACA;AACA,IAAI,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,QAAQ,EAAE;AACzC,MAAM,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;AAC/C;AACA;AACA,IAAI,MAAM,QAAQ,GAAG,YAAY,CAAC,MAAM,EAAE,WAAW;AACrD,IAAI,IAAI,QAAQ,EAAE,cAAc,CAAC,QAAQ,EAAE,KAAK;AAChD,IAAI,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,cAAc,CAAC,GAAG,EAAE,KAAK,EAAE;AACpC,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACvC,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC;AACtC,KAAK,MAAM;AACX,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,YAAY,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE;AAC3C,EAAE,MAAM,GAAG,GAAG;AACd,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACxC,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,EAAC;AAC3D,KAAK,MAAM;AACX,MAAM,IAAI,IAAI,CAAC,CAAC,CAAC,EAAE;AACnB;AACA,QAAQ,MAAM,GAAG,GAAG;AACpB,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACjD,UAAU,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AACnC,UAAU,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,KAAK,SAAS,GAAG,IAAI,GAAG;AACzD;AACA,QAAQ,GAAG,CAAC,IAAI,CAAC,GAAG;AACpB,OAAO,MAAM;AACb,QAAQ,GAAG,CAAC,IAAI,CAAC,SAAS;AAC1B;AACA;AACA;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,YAAY,CAAC,MAAM,EAAE,KAAK,EAAE;AACrC,EAAE,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM;AACjC,EAAE,MAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;AAClC,EAAE,MAAM,GAAG,GAAG;AACd,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;AACnC;AACA,IAAI,MAAM,GAAG,GAAG;AAChB,IAAI,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;AAC5B,MAAM,IAAI,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,MAAM,EAAE,MAAM,IAAI,KAAK,CAAC,8BAA8B;AACvF,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;AAC9B;AACA,IAAI,IAAI,KAAK,EAAE;AACf,MAAM,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK,GAAG,CAAC,CAAC,EAAC;AAC5C,KAAK,MAAM;AACX,MAAM,GAAG,CAAC,IAAI,CAAC,GAAG;AAClB;AACA;AACA,EAAE,OAAO;AACT;;ACtPA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,iBAAiB,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE;AACzD,EAAE,MAAM,KAAK,GAAG,MAAM,YAAY;AAClC,EAAE,MAAM,SAAS,GAAG,UAAU,CAAC,MAAM;AACrC,EAAE,MAAM,iBAAiB,GAAG,UAAU,CAAC,MAAM;AAC7C,EAAE,UAAU,CAAC,MAAM,EAAC;AACpB,EAAE,IAAI,KAAK,GAAG,gBAAgB,CAAC,MAAM,EAAC;AACtC,EAAE,IAAI,WAAW,GAAG;AACpB,EAAE,MAAM,CAAC,WAAW,EAAE,CAAC,GAAG,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG;;AAElD,EAAE,MAAM,kBAAkB,GAAG,SAAS,GAAG;;AAEzC,EAAE,OAAO,WAAW,GAAG,KAAK,EAAE;AAC9B;AACA,IAAI,MAAM,QAAQ,GAAG,gBAAgB,CAAC,MAAM;AAC5C,IAAI,MAAM,SAAS,GAAG,IAAI,UAAU,CAAC,iBAAiB;AACtD,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,iBAAiB,EAAE,CAAC,EAAE,EAAE;AAChD,MAAM,SAAS,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE;AACzD;;AAEA,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,iBAAiB,IAAI,WAAW,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AACvE;AACA,MAAM,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC;AAC1C,MAAM,IAAI,QAAQ,EAAE;AACpB,QAAQ,IAAI,UAAU,GAAG;AACzB,QAAQ,IAAI,cAAc,GAAG;AAC7B,QAAQ,MAAM,IAAI,GAAG,CAAC,EAAE,IAAI,QAAQ,IAAI;AACxC,QAAQ,OAAO,cAAc,IAAI,WAAW,GAAG,KAAK,EAAE;AACtD,UAAU,IAAI,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,UAAU,GAAG,KAAI;AACrF,UAAU,UAAU,IAAI;AACxB,UAAU,OAAO,UAAU,IAAI,CAAC,EAAE;AAClC,YAAY,UAAU,IAAI;AAC1B,YAAY,MAAM,CAAC,MAAM;AACzB,YAAY,IAAI,UAAU,EAAE;AAC5B,cAAc,IAAI,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,QAAQ,GAAG,UAAU,GAAG;AAC7F;AACA;AACA,UAAU,MAAM,KAAK,GAAG,QAAQ,GAAG;AACnC,UAAU,KAAK,IAAI;AACnB,UAAU,MAAM,CAAC,WAAW,EAAE,CAAC,GAAG,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG;AAC1D,UAAU,cAAc;AACxB;AACA,QAAQ,IAAI,cAAc,EAAE;AAC5B;AACA,UAAU,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,cAAc,GAAG,MAAM,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC;AACjG;AACA,OAAO,MAAM;AACb,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,kBAAkB,IAAI,WAAW,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AAC5E,UAAU,KAAK,IAAI;AACnB,UAAU,MAAM,CAAC,WAAW,EAAE,CAAC,GAAG,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO,SAAS,oBAAoB,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE;AAC5D,EAAE,MAAM,OAAO,GAAG,IAAI,UAAU,CAAC,KAAK;AACtC,EAAE,iBAAiB,CAAC,MAAM,EAAE,KAAK,EAAE,OAAO;AAC1C,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AAClC,IAAI,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;AACrG,IAAI,MAAM,CAAC,MAAM,IAAI,OAAO,CAAC,CAAC;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO,SAAS,cAAc,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE;AACtD,EAAE,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,KAAK;AACzC,EAAE,iBAAiB,CAAC,MAAM,EAAE,KAAK,EAAE,UAAU;AAC7C,EAAE,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,KAAK;AACzC,EAAE,iBAAiB,CAAC,MAAM,EAAE,KAAK,EAAE,UAAU;;AAE7C,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AAClC,IAAI,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC,CAAC;AAC3G,IAAI,IAAI,UAAU,CAAC,CAAC,CAAC,EAAE;AACvB;AACA,MAAM,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC;AAC9D,MAAM,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC;AAC5D,MAAM,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC,CAAC;AACzC,KAAK,MAAM;AACX,MAAM,MAAM,CAAC,CAAC,CAAC,GAAG;AAClB;AACA,IAAI,MAAM,CAAC,MAAM,IAAI,UAAU,CAAC,CAAC;AACjC;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,QAAQ,CAAC,KAAK,EAAE;AAChC,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,sBAAsB,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE;AACtE,EAAE,IAAI,CAAC,MAAM,EAAE;AACf;AACA,IAAI,MAAM,CAAC,MAAM,IAAI;AACrB;AACA,EAAE,IAAI,IAAI,GAAG;AACb,EAAE,OAAO,IAAI,GAAG,MAAM,CAAC,MAAM,EAAE;AAC/B,IAAI,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM;AACpC,IAAI,IAAI,MAAM,GAAG,CAAC,EAAE;AACpB;AACA,MAAM,IAAI,GAAG,aAAa,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI;AAC9D,KAAK,MAAM;AACX;AACA,MAAM,MAAM,KAAK,GAAG,MAAM,KAAK;AAC/B,MAAM,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI;AAChD,MAAM,IAAI,IAAI;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE;AACxD,EAAE,MAAM,KAAK,GAAG,QAAQ,GAAG,CAAC,IAAI;AAChC,EAAE,IAAI,KAAK,GAAG;AACd,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AAClC,IAAI,KAAK,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC;AAC7D;AACA;;AAEA;AACA,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AAClC,IAAI,MAAM,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,aAAa,CAAC,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE;AAC/D,EAAE,IAAI,KAAK,GAAG,MAAM,IAAI,CAAC,IAAI,EAAC;AAC9B,EAAE,MAAM,IAAI,GAAG,CAAC,CAAC,IAAI,QAAQ,IAAI;;AAEjC,EAAE,IAAI,IAAI,GAAG;AACb,EAAE,IAAI,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,EAAE;AAC9C,IAAI,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE;AAC/C,GAAG,MAAM,IAAI,IAAI,EAAE;AACnB;AACA,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,uBAAuB,EAAE,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC;AAC1E;AACA,EAAE,IAAI,IAAI,GAAG;AACb,EAAE,IAAI,KAAK,GAAG;;AAEd;AACA,EAAE,OAAO,KAAK,EAAE;AAChB;AACA,IAAI,IAAI,KAAK,GAAG,CAAC,EAAE;AACnB,MAAM,KAAK,IAAI;AACf,MAAM,IAAI,IAAI;AACd,MAAM,IAAI,MAAM;AAChB,KAAK,MAAM,IAAI,IAAI,GAAG,KAAK,GAAG,QAAQ,EAAE;AACxC;AACA,MAAM,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI;AACrD,MAAM,MAAM,CAAC,MAAM;AACnB,MAAM,IAAI,IAAI;AACd,KAAK,MAAM;AACX,MAAM,IAAI,IAAI,GAAG,MAAM,CAAC,MAAM,EAAE;AAChC;AACA,QAAQ,MAAM,CAAC,IAAI,EAAE,CAAC,GAAG,IAAI,IAAI,KAAK,GAAG;AACzC;AACA,MAAM,KAAK;AACX,MAAM,KAAK,IAAI;AACf;AACA;;AAEA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,eAAe,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE;AACjE,EAAE,MAAM,KAAK,GAAG,SAAS,CAAC,IAAI,EAAE,UAAU;AAC1C,EAAE,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,KAAK,GAAG,KAAK;AAC5C,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AAClC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AACpC,MAAM,KAAK,CAAC,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE;AACjE;AACA;AACA;AACA,EAAE,IAAI,IAAI,KAAK,OAAO,EAAE,OAAO,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM;AAC5D,OAAO,IAAI,IAAI,KAAK,QAAQ,EAAE,OAAO,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM;AAClE,OAAO,IAAI,IAAI,KAAK,OAAO,EAAE,OAAO,IAAI,UAAU,CAAC,KAAK,CAAC,MAAM;AAC/D,OAAO,IAAI,IAAI,KAAK,OAAO,EAAE,OAAO,IAAI,aAAa,CAAC,KAAK,CAAC,MAAM;AAClE,OAAO,IAAI,IAAI,KAAK,sBAAsB,EAAE;AAC5C;AACA,IAAI,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,KAAK;AACjC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AACpC,MAAM,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC,GAAG,KAAK,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,KAAK;AAC1D;AACA,IAAI,OAAO;AACX;AACA,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,4CAA4C,EAAE,IAAI,CAAC,CAAC;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS,CAAC,IAAI,EAAE,UAAU,EAAE;AACrC,EAAE,QAAQ,IAAI;AACd,EAAE,KAAK,OAAO;AACd,EAAE,KAAK,OAAO;AACd,IAAI,OAAO;AACX,EAAE,KAAK,OAAO;AACd,EAAE,KAAK,QAAQ;AACf,IAAI,OAAO;AACX,EAAE,KAAK,sBAAsB;AAC7B,IAAI,IAAI,CAAC,UAAU,EAAE,MAAM,IAAI,KAAK,CAAC,uCAAuC;AAC5E,IAAI,OAAO;AACX,EAAE;AACF,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,0BAA0B,EAAE,IAAI,CAAC,CAAC;AACvD;AACA;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,SAAS,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,WAAW,EAAE;AAC5D,EAAE,IAAI,KAAK,KAAK,CAAC,EAAE,OAAO;AAC1B,EAAE,IAAI,IAAI,KAAK,SAAS,EAAE;AAC1B,IAAI,OAAO,gBAAgB,CAAC,MAAM,EAAE,KAAK;AACzC,GAAG,MAAM,IAAI,IAAI,KAAK,OAAO,EAAE;AAC/B,IAAI,OAAO,cAAc,CAAC,MAAM,EAAE,KAAK;AACvC,GAAG,MAAM,IAAI,IAAI,KAAK,OAAO,EAAE;AAC/B,IAAI,OAAO,cAAc,CAAC,MAAM,EAAE,KAAK;AACvC,GAAG,MAAM,IAAI,IAAI,KAAK,OAAO,EAAE;AAC/B,IAAI,OAAO,cAAc,CAAC,MAAM,EAAE,KAAK;AACvC,GAAG,MAAM,IAAI,IAAI,KAAK,OAAO,EAAE;AAC/B,IAAI,OAAO,cAAc,CAAC,MAAM,EAAE,KAAK;AACvC,GAAG,MAAM,IAAI,IAAI,KAAK,QAAQ,EAAE;AAChC,IAAI,OAAO,eAAe,CAAC,MAAM,EAAE,KAAK;AACxC,GAAG,MAAM,IAAI,IAAI,KAAK,YAAY,EAAE;AACpC,IAAI,OAAO,kBAAkB,CAAC,MAAM,EAAE,KAAK;AAC3C,GAAG,MAAM,IAAI,IAAI,KAAK,sBAAsB,EAAE;AAC9C,IAAI,IAAI,CAAC,WAAW,EAAE,MAAM,IAAI,KAAK,CAAC,8BAA8B;AACpE,IAAI,OAAO,uBAAuB,CAAC,MAAM,EAAE,KAAK,EAAE,WAAW;AAC7D,GAAG,MAAM;AACT,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,wBAAwB,EAAE,IAAI,CAAC,CAAC;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,gBAAgB,CAAC,MAAM,EAAE,KAAK,EAAE;AACzC,EAAE,MAAM,MAAM,GAAG,IAAI,KAAK,CAAC,KAAK;AAChC,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AAClC,IAAI,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;AACjD,IAAI,MAAM,SAAS,GAAG,CAAC,GAAG;AAC1B,IAAI,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU;AAChD,IAAI,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,IAAI,SAAS,MAAM;AAC5C;AACA,EAAE,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC;AACtC,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc,CAAC,MAAM,EAAE,KAAK,EAAE;AACvC,EAAE,MAAM,MAAM,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,IAAI;AAC5D,MAAM,IAAI,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,KAAK,GAAG,CAAC,CAAC;AACjG,MAAM,IAAI,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,KAAK;AACtF,EAAE,MAAM,CAAC,MAAM,IAAI,KAAK,GAAG;AAC3B,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc,CAAC,MAAM,EAAE,KAAK,EAAE;AACvC,EAAE,MAAM,MAAM,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,IAAI;AAC5D,MAAM,IAAI,aAAa,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,KAAK,GAAG,CAAC,CAAC;AACpG,MAAM,IAAI,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,KAAK;AACzF,EAAE,MAAM,CAAC,MAAM,IAAI,KAAK,GAAG;AAC3B,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc,CAAC,MAAM,EAAE,KAAK,EAAE;AACvC,EAAE,MAAM,MAAM,GAAG,IAAI,KAAK,CAAC,KAAK;AAChC,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AAClC,IAAI,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,GAAG,EAAE,EAAE,IAAI;AACpE,IAAI,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,IAAI;AACtE,IAAI,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,GAAG,GAAG;AACtC;AACA,EAAE,MAAM,CAAC,MAAM,IAAI,KAAK,GAAG;AAC3B,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc,CAAC,MAAM,EAAE,KAAK,EAAE;AACvC,EAAE,MAAM,MAAM,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,IAAI;AAC5D,MAAM,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,KAAK,GAAG,CAAC,CAAC;AACnG,MAAM,IAAI,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,KAAK;AACxF,EAAE,MAAM,CAAC,MAAM,IAAI,KAAK,GAAG;AAC3B,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,eAAe,CAAC,MAAM,EAAE,KAAK,EAAE;AACxC,EAAE,MAAM,MAAM,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,IAAI;AAC5D,MAAM,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,KAAK,GAAG,CAAC,CAAC;AACnG,MAAM,IAAI,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,KAAK;AACxF,EAAE,MAAM,CAAC,MAAM,IAAI,KAAK,GAAG;AAC3B,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kBAAkB,CAAC,MAAM,EAAE,KAAK,EAAE;AAC3C,EAAE,MAAM,MAAM,GAAG,IAAI,KAAK,CAAC,KAAK;AAChC,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AAClC,IAAI,MAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI;AAC3D,IAAI,MAAM,CAAC,MAAM,IAAI;AACrB,IAAI,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM;AACjG,IAAI,MAAM,CAAC,MAAM,IAAI;AACrB;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uBAAuB,CAAC,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE;AAC7D;AACA,EAAE,MAAM,MAAM,GAAG,IAAI,KAAK,CAAC,KAAK;AAChC,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AAClC,IAAI,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,WAAW;AACtG,IAAI,MAAM,CAAC,MAAM,IAAI;AACrB;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAK,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE;AACrC,EAAE,MAAM,OAAO,GAAG,IAAI,WAAW,CAAC,IAAI;AACtC,EAAE,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,IAAI,UAAU,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC;AAClE,EAAE,OAAO;AACT;;ACnLA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAS,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,UAAU;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS,CAAC,SAAS,EAAE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE;AAC/D,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;AACnC,IAAI,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,SAAS,CAAC,OAAO,GAAG,CAAC;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,aAAa,CAAC,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE;AACnD,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;AACnC,IAAI,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,GAAG,MAAM,GAAG,CAAC;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,gBAAgB,CAAC,KAAK,EAAE,MAAM,EAAE;AAChD,EAAE,MAAM,WAAW,GAAG,KAAK,CAAC;AAC5B,EAAE,MAAM,YAAY,GAAG,MAAM,CAAC;AAC9B,EAAE,IAAI,GAAG,GAAG;AACZ,EAAE,IAAI,MAAM,GAAG;;AAEf;AACA,EAAE,OAAO,GAAG,GAAG,WAAW,EAAE;AAC5B,IAAI,MAAM,CAAC,GAAG,KAAK,CAAC,GAAG;AACvB,IAAI,GAAG;AACP,IAAI,IAAI,CAAC,GAAG,GAAG,EAAE;AACjB,MAAM;AACN;AACA;AACA,EAAE,IAAI,YAAY,IAAI,GAAG,IAAI,WAAW,EAAE;AAC1C,IAAI,MAAM,IAAI,KAAK,CAAC,8BAA8B;AAClD;;AAEA,EAAE,OAAO,GAAG,GAAG,WAAW,EAAE;AAC5B,IAAI,MAAM,CAAC,GAAG,KAAK,CAAC,GAAG;AACvB,IAAI,IAAI,GAAG,GAAG;AACd,IAAI,GAAG;;AAEP,IAAI,IAAI,GAAG,IAAI,WAAW,EAAE;AAC5B,MAAM,MAAM,IAAI,KAAK,CAAC,oBAAoB;AAC1C;;AAEA;AACA,IAAI,IAAI,CAAC,CAAC,GAAG,GAAG,MAAM,CAAC,EAAE;AACzB;AACA,MAAM,IAAI,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI;AAC5B;AACA,MAAM,IAAI,GAAG,GAAG,EAAE,EAAE;AACpB,QAAQ,IAAI,GAAG,GAAG,CAAC,IAAI,WAAW,EAAE;AACpC,UAAU,MAAM,IAAI,KAAK,CAAC,6CAA6C;AACvE;AACA,QAAQ,MAAM,UAAU,GAAG,GAAG,GAAG,GAAE;AACnC,QAAQ,GAAG,GAAG,KAAK,CAAC,GAAG;AACvB,aAAa,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC;AAChC,aAAa,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,EAAE;AACjC,aAAa,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,EAAE;AACjC,QAAQ,GAAG,GAAG,CAAC,GAAG,GAAG,SAAS,CAAC,UAAU,CAAC,IAAI;AAC9C,QAAQ,GAAG,IAAI;AACf;AACA,MAAM,IAAI,GAAG,GAAG,GAAG,GAAG,WAAW,EAAE;AACnC,QAAQ,MAAM,IAAI,KAAK,CAAC,2CAA2C;AACnE;AACA,MAAM,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG;AAC/C,MAAM,GAAG,IAAI;AACb,MAAM,MAAM,IAAI;AAChB,KAAK,MAAM;AACX;AACA,MAAM,IAAI,MAAM,GAAG,EAAC;AACpB,MAAM,QAAQ,CAAC,GAAG,GAAG;AACrB,MAAM,KAAK,CAAC;AACZ;AACA,QAAQ,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI;AAChC,QAAQ,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;AAC3C,QAAQ,GAAG;AACX,QAAQ;AACR,MAAM,KAAK,CAAC;AACZ;AACA,QAAQ,IAAI,WAAW,IAAI,GAAG,GAAG,CAAC,EAAE;AACpC,UAAU,MAAM,IAAI,KAAK,CAAC,2BAA2B;AACrD;AACA,QAAQ,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI;AAC1B,QAAQ,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC;AAClD,QAAQ,GAAG,IAAI;AACf,QAAQ;AACR,MAAM,KAAK,CAAC;AACZ;AACA,QAAQ,IAAI,WAAW,IAAI,GAAG,GAAG,CAAC,EAAE;AACpC,UAAU,MAAM,IAAI,KAAK,CAAC,2BAA2B;AACrD;AACA,QAAQ,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI;AAC1B,QAAQ,MAAM,GAAG,KAAK,CAAC,GAAG;AAC1B,aAAa,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC;AAChC,aAAa,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,EAAE;AACjC,aAAa,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,EAAE;AACjC,QAAQ,GAAG,IAAI;AACf,QAAQ;AAGR;AACA,MAAM,IAAI,MAAM,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,EAAE;AACzC,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,eAAe,EAAE,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;AACxF;AACA,MAAM,IAAI,MAAM,GAAG,MAAM,EAAE;AAC3B,QAAQ,MAAM,IAAI,KAAK,CAAC,yCAAyC;AACjE;AACA,MAAM,aAAa,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG;AAC/C,MAAM,MAAM,IAAI;AAChB;AACA;;AAEA,EAAE,IAAI,MAAM,KAAK,YAAY,EAAE,MAAM,IAAI,KAAK,CAAC,wBAAwB;AACvE;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,YAAY,CAAC,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,EAAE,IAAI,EAAE,EAAE;AAChE,EAAE,MAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU;AAC5E,EAAE,MAAM,MAAM,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;AAClC;AACA,EAAE,IAAI;;AAEN;AACA,EAAE,MAAM,gBAAgB,GAAG,oBAAoB,CAAC,MAAM,EAAE,IAAI,EAAE,UAAU;AACxE;AACA,EAAE,MAAM,EAAE,gBAAgB,EAAE,QAAQ,EAAE,GAAG,oBAAoB,CAAC,MAAM,EAAE,IAAI,EAAE,UAAU;AACtF;;AAEA;AACA,EAAE,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,GAAG;AACpC,EAAE,IAAI,IAAI,CAAC,QAAQ,KAAK,OAAO,EAAE;AACjC,IAAI,MAAM,EAAE,WAAW,EAAE,GAAG,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC9D,IAAI,QAAQ,GAAG,SAAS,CAAC,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,WAAW;AAC3D,GAAG,MAAM;AACT,IAAI,IAAI,CAAC,QAAQ,KAAK,kBAAkB;AACxC,IAAI,IAAI,CAAC,QAAQ,KAAK,gBAAgB;AACtC,IAAI,IAAI,CAAC,QAAQ,KAAK;AACtB,IAAI;AACJ,IAAI,MAAM,QAAQ,GAAG,IAAI,KAAK,SAAS,GAAG,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE;AAC3E,IAAI,IAAI,QAAQ,EAAE;AAClB,MAAM,QAAQ,GAAG,IAAI,KAAK,CAAC,OAAO;AAClC,MAAM,sBAAsB,CAAC,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,QAAQ;AACxF,KAAK,MAAM;AACX,MAAM,QAAQ,GAAG,IAAI,UAAU,CAAC,OAAO,EAAC;AACxC;AACA,GAAG,MAAM,IAAI,IAAI,CAAC,QAAQ,KAAK,mBAAmB,EAAE;AACpD,IAAI,MAAM,EAAE,WAAW,EAAE,GAAG,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC9D,IAAI,QAAQ,GAAG,eAAe,CAAC,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,WAAW;AACjE,GAAG,MAAM;AACT,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,8BAA8B,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;AACpE;;AAEA,EAAE,OAAO,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,QAAQ;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,kBAAkB,CAAC,KAAK,EAAE,IAAI,EAAE,cAAc,EAAE,UAAU,EAAE;AAC5E,EAAE,MAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU;AAC5E,EAAE,MAAM,MAAM,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;AAClC,EAAE,OAAO,SAAS,CAAC,MAAM,EAAE,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,UAAU;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB,CAAC,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE;AACxD,EAAE,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE;AAC7B,IAAI,MAAM,kBAAkB,GAAG,qBAAqB,CAAC,UAAU;AAC/D,IAAI,IAAI,kBAAkB,EAAE;AAC5B,MAAM,MAAM,MAAM,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,UAAU;AAC9C,MAAM,sBAAsB,CAAC,MAAM,EAAE,QAAQ,CAAC,kBAAkB,CAAC,EAAE,CAAC,EAAE,MAAM;AAC5E,MAAM,OAAO;AACb;AACA;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB,CAAC,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE;AACxD,EAAE,MAAM,kBAAkB,GAAG,qBAAqB,CAAC,UAAU;AAC7D,EAAE,IAAI,CAAC,kBAAkB,EAAE,OAAO,EAAE,gBAAgB,EAAE,EAAE,EAAE,QAAQ,EAAE,CAAC;;AAErE,EAAE,MAAM,gBAAgB,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,UAAU;AACpD,EAAE,sBAAsB,CAAC,MAAM,EAAE,QAAQ,CAAC,kBAAkB,CAAC,EAAE,CAAC,EAAE,gBAAgB;;AAElF;AACA,EAAE,IAAI,QAAQ,GAAG,IAAI,CAAC;AACtB,EAAE,KAAK,MAAM,GAAG,IAAI,gBAAgB,EAAE;AACtC,IAAI,IAAI,GAAG,KAAK,kBAAkB,EAAE,QAAQ;AAC5C;AACA,EAAE,IAAI,QAAQ,KAAK,CAAC,EAAE,gBAAgB,CAAC,MAAM,GAAG;;AAEhD,EAAE,OAAO,EAAE,gBAAgB,EAAE,QAAQ;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,cAAc,CAAC,eAAe,EAAE,sBAAsB,EAAE,KAAK,EAAE,WAAW,EAAE;AAC5F;AACA,EAAE,IAAI;AACN,EAAE,MAAM,kBAAkB,GAAG,WAAW,GAAG,KAAK;AAChD,EAAE,IAAI,KAAK,KAAK,cAAc,EAAE;AAChC,IAAI,IAAI,GAAG;AACX,GAAG,MAAM,IAAI,kBAAkB,EAAE;AACjC,IAAI,IAAI,GAAG,kBAAkB,CAAC,eAAe,EAAE,sBAAsB;AACrE,GAAG,MAAM,IAAI,KAAK,KAAK,QAAQ,EAAE;AACjC,IAAI,IAAI,GAAG,IAAI,UAAU,CAAC,sBAAsB;AAChD,IAAI,gBAAgB,CAAC,eAAe,EAAE,IAAI;AAC1C,GAAG,MAAM;AACT,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,uCAAuC,EAAE,KAAK,CAAC,CAAC;AACrE;AACA,EAAE,IAAI,IAAI,EAAE,MAAM,KAAK,sBAAsB,EAAE;AAC/C,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,iCAAiC,EAAE,IAAI,EAAE,MAAM,CAAC,uBAAuB,EAAE,sBAAsB,CAAC,CAAC;AACtH;AACA,EAAE,OAAO;AACT;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,cAAc,CAAC,eAAe,EAAE,EAAE,EAAE,UAAU,EAAE,cAAc,EAAE,WAAW,EAAE;AAC7F,EAAE,MAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,eAAe,CAAC,MAAM,EAAE,eAAe,CAAC,UAAU,EAAE,eAAe,CAAC,UAAU;AAC1G,EAAE,MAAM,MAAM,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;AAClC,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG;AAC1B,EAAE,MAAM,KAAK,GAAG,EAAE,CAAC;AACnB,EAAE,IAAI,CAAC,KAAK,EAAE,MAAM,IAAI,KAAK,CAAC,0CAA0C;;AAExE;AACA,EAAE,MAAM,gBAAgB,GAAG,sBAAsB,CAAC,MAAM,EAAE,KAAK,EAAE,UAAU;AAC3E,EAAE,MAAM,CAAC,MAAM,GAAG,KAAK,CAAC,8BAA6B;;AAErD;AACA,EAAE,MAAM,gBAAgB,GAAG,sBAAsB,CAAC,MAAM,EAAE,KAAK,EAAE,UAAU;AAC3E;;AAEA,EAAE,MAAM,oBAAoB,GAAG,EAAE,CAAC,sBAAsB,GAAG,KAAK,CAAC,6BAA6B,GAAG,KAAK,CAAC;;AAEvG,EAAE,IAAI,IAAI,GAAG,eAAe,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM;AACnD,EAAE,IAAI,KAAK,CAAC,aAAa,KAAK,KAAK,EAAE;AACrC,IAAI,IAAI,GAAG,cAAc,CAAC,IAAI,EAAE,oBAAoB,EAAE,KAAK,EAAE,WAAW;AACxE;AACA,EAAE,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,UAAU;AAC7E,EAAE,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC;;AAEhD;AACA;AACA,EAAE,IAAI;AACN,EAAE,MAAM,OAAO,GAAG,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;AAC3C,EAAE,IAAI,KAAK,CAAC,QAAQ,KAAK,OAAO,EAAE;AAClC,IAAI,MAAM,EAAE,WAAW,EAAE,GAAG,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC9D,IAAI,QAAQ,GAAG,SAAS,CAAC,UAAU,EAAE,IAAI,EAAE,OAAO,EAAE,WAAW;AAC/D,GAAG,MAAM,IAAI,KAAK,CAAC,QAAQ,KAAK,KAAK,EAAE;AACvC;AACA,IAAI,QAAQ,GAAG,IAAI,KAAK,CAAC,OAAO;AAChC,IAAI,sBAAsB,CAAC,UAAU,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ;AACrD,IAAI,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;AACpC,GAAG,MAAM;AACT,IAAI,KAAK,CAAC,QAAQ,KAAK,kBAAkB;AACzC,IAAI,KAAK,CAAC,QAAQ,KAAK;AACvB,IAAI;AACJ,IAAI,MAAM,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE;AAC1D,IAAI,QAAQ,GAAG,IAAI,KAAK,CAAC,OAAO;AAChC,IAAI,sBAAsB,CAAC,UAAU,EAAE,QAAQ,EAAE,oBAAoB,GAAG,CAAC,EAAE,QAAQ;AACnF,GAAG,MAAM,IAAI,KAAK,CAAC,QAAQ,KAAK,qBAAqB,EAAE;AACvD,IAAI,MAAM,KAAK,GAAG,IAAI,KAAK;AAC3B,IAAI,QAAQ,GAAG,KAAK,GAAG,IAAI,UAAU,CAAC,OAAO,CAAC,GAAG,IAAI,aAAa,CAAC,OAAO;AAC1E,IAAI,iBAAiB,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ;AACnD,GAAG,MAAM,IAAI,KAAK,CAAC,QAAQ,KAAK,yBAAyB,EAAE;AAC3D,IAAI,QAAQ,GAAG,IAAI,KAAK,CAAC,OAAO;AAChC,IAAI,oBAAoB,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ;AACtD,GAAG,MAAM,IAAI,KAAK,CAAC,QAAQ,KAAK,kBAAkB,EAAE;AACpD,IAAI,QAAQ,GAAG,IAAI,KAAK,CAAC,OAAO;AAChC,IAAI,cAAc,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ;AAChD,GAAG,MAAM,IAAI,KAAK,CAAC,QAAQ,KAAK,mBAAmB,EAAE;AACrD,IAAI,MAAM,EAAE,WAAW,EAAE,GAAG,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC9D,IAAI,QAAQ,GAAG,eAAe,CAAC,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,WAAW;AACjE,GAAG,MAAM;AACT,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,8BAA8B,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC;AACrE;;AAEA,EAAE,OAAO,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,QAAQ;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sBAAsB,CAAC,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE;AAC3D,EAAE,MAAM,kBAAkB,GAAG,qBAAqB,CAAC,UAAU;AAC7D,EAAE,IAAI,CAAC,kBAAkB,EAAE,OAAO;;AAElC,EAAE,MAAM,MAAM,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,UAAU;AAC3C,EAAE,sBAAsB;AACxB,IAAI,MAAM,EAAE,QAAQ,CAAC,kBAAkB,CAAC,EAAE,KAAK,CAAC,6BAA6B,EAAE;AAC/E;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sBAAsB,CAAC,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE;AAC3D,EAAE,MAAM,kBAAkB,GAAG,qBAAqB,CAAC,UAAU;AAC7D,EAAE,IAAI,kBAAkB,EAAE;AAC1B;AACA,IAAI,MAAM,MAAM,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,UAAU;AAC7C,IAAI,sBAAsB,CAAC,MAAM,EAAE,QAAQ,CAAC,kBAAkB,CAAC,EAAE,KAAK,CAAC,6BAA6B,EAAE,MAAM;AAC5G,IAAI,OAAO;AACX;AACA;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,MAAM,CAAC,GAAG,EAAE;AAC5B,EAAE,IAAI,GAAG,KAAK,SAAS,EAAE,OAAO;AAChC,EAAE,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,OAAO,MAAM,CAAC,GAAG;AAChD,EAAE,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,OAAO,GAAG,CAAC,GAAG,CAAC,MAAM;AAC/C,EAAE,IAAI,GAAG,YAAY,UAAU,EAAE,OAAO,KAAK,CAAC,IAAI,CAAC,GAAG;AACtD,EAAE,IAAI,GAAG,YAAY,IAAI,EAAE,OAAO,GAAG,CAAC,WAAW;AACjD,EAAE,IAAI,GAAG,YAAY,MAAM,EAAE;AAC7B;AACA,IAAI,MAAM,MAAM,GAAG;AACnB,IAAI,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;AACxC,MAAM,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,SAAS,EAAE;AAClC,MAAM,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC;AACnC;AACA,IAAI,OAAO;AACX;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE;AACjC,EAAE,MAAM,KAAK,GAAG;AAChB,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,IAAI,KAAK,EAAE;AAC9C,IAAI,GAAG,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,iBAAiB,CAAC,GAAG,EAAE,WAAW,EAAE;AAC1D,EAAE,OAAO,MAAM,KAAK,CAAC,GAAG,EAAE,EAAE,GAAG,WAAW,EAAE,MAAM,EAAE,MAAM,EAAE;AAC5D,KAAK,IAAI,CAAC,GAAG,IAAI;AACjB,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,kBAAkB,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;AACpE,MAAM,MAAM,MAAM,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB;AACrD,MAAM,IAAI,CAAC,MAAM,EAAE,MAAM,IAAI,KAAK,CAAC,wBAAwB;AAC3D,MAAM,OAAO,QAAQ,CAAC,MAAM;AAC5B,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,kBAAkB,CAAC,EAAE,GAAG,EAAE,UAAU,EAAE,WAAW,EAAE,EAAE;AAC3E;AACA,EAAE,UAAU,KAAK,MAAM,iBAAiB,CAAC,GAAG,EAAE,WAAW;AACzD,EAAE,MAAM,IAAI,GAAG,WAAW,IAAI;AAC9B,EAAE,OAAO;AACT,IAAI,UAAU;AACd,IAAI,MAAM,KAAK,CAAC,KAAK,EAAE,GAAG,EAAE;AAC5B;AACA,MAAM,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,IAAI,CAAC,OAAO;AAC9C,MAAM,MAAM,MAAM,GAAG,GAAG,KAAK,SAAS,GAAG,EAAE,GAAG,GAAG,GAAG;AACpD,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;AACrD,MAAM,MAAM,GAAG,GAAG,MAAM,KAAK,CAAC,GAAG,EAAE,EAAE,GAAG,IAAI,EAAE,OAAO,EAAE;AACvD,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,aAAa,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;AAC5E,MAAM,OAAO,GAAG,CAAC,WAAW;AAC5B,KAAK;AACL;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,UAAU,CAAC,MAAM,EAAE,QAAQ,EAAE,cAAc,EAAE,UAAU,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,EAAE;AAChG,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC;AACtD;AACA,EAAE,IAAI,UAAU,GAAG;AACnB;AACA,EAAE,MAAM,OAAO,GAAG;;AAElB,EAAE,OAAO,OAAO,CAAC,MAAM,GAAG,QAAQ,EAAE;AACpC;AACA,IAAI,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM;AACvC;;AAEA;AACA,IAAI,MAAM,eAAe,GAAG,IAAI,UAAU;AAC1C,MAAM,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC;AACzE;;AAEA;AACA;AACA,IAAI,IAAI;AACR,IAAI,IAAI,MAAM,CAAC,IAAI,KAAK,WAAW,EAAE;AACrC,MAAM,MAAM,IAAI,GAAG,MAAM,CAAC;AAC1B,MAAM,IAAI,CAAC,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,uCAAuC;;AAExE,MAAM,MAAM,IAAI,GAAG,cAAc,CAAC,eAAe,EAAE,MAAM,CAAC,MAAM,CAAC,sBAAsB,CAAC,EAAE,cAAc,CAAC,KAAK,EAAE,WAAW;AAC3H,MAAM,MAAM,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,QAAQ,EAAE,GAAG,YAAY,CAAC,IAAI,EAAE,IAAI,EAAE,UAAU,EAAE,cAAc;AAClH;;AAEA;AACA,MAAM,MAAM,GAAG,qBAAqB,CAAC,QAAQ,EAAE,UAAU,EAAE,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI;AACvF,MAAM,IAAI,gBAAgB,CAAC,MAAM,IAAI,gBAAgB,EAAE,MAAM,EAAE;AAC/D,QAAQ,MAAM,kBAAkB,GAAG,qBAAqB,CAAC,UAAU;AACnE,QAAQ,MAAM,cAAc,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,KAAK,OAAO,CAAC,eAAe;AACtF,QAAQ,aAAa;AACrB,UAAU,OAAO,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,MAAM,EAAE,cAAc,EAAE;AAC/E;AACA,OAAO,MAAM;AACb;AACA,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACpD,UAAU,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,eAAe,KAAK,UAAU,EAAE;AACpE,YAAY,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;AAChD;AACA;AACA,QAAQ,MAAM,CAAC,OAAO,EAAE,MAAM;AAC9B;AACA,KAAK,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,cAAc,EAAE;AAC/C,MAAM,MAAM,KAAK,GAAG,MAAM,CAAC;AAC3B,MAAM,IAAI,CAAC,KAAK,EAAE,MAAM,IAAI,KAAK,CAAC,0CAA0C;;AAE5E,MAAM,MAAM,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,QAAQ,EAAE,GAAG,cAAc;AAC7E,QAAQ,eAAe,EAAE,MAAM,EAAE,UAAU,EAAE,cAAc,EAAE;AAC7D;;AAEA;AACA,MAAM,MAAM,GAAG,qBAAqB,CAAC,QAAQ,EAAE,UAAU,EAAE,OAAO,EAAE,KAAK,CAAC,QAAQ,EAAE,IAAI;AACxF,MAAM,IAAI,gBAAgB,CAAC,MAAM,IAAI,gBAAgB,EAAE,MAAM,EAAE;AAC/D,QAAQ,MAAM,kBAAkB,GAAG,qBAAqB,CAAC,UAAU;AACnE,QAAQ,MAAM,cAAc,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,KAAK,OAAO,CAAC,eAAe;AACtF,QAAQ,aAAa;AACrB,UAAU,OAAO,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,MAAM,EAAE,cAAc,EAAE;AAC/E;AACA,OAAO,MAAM;AACb,QAAQ,MAAM,CAAC,OAAO,EAAE,MAAM;AAC9B;AACA,KAAK,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,iBAAiB,EAAE;AAClD,MAAM,MAAM,IAAI,GAAG,MAAM,CAAC;AAC1B,MAAM,IAAI,CAAC,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,6CAA6C;;AAE9E,MAAM,MAAM,IAAI,GAAG,cAAc;AACjC,QAAQ,eAAe,EAAE,MAAM,CAAC,MAAM,CAAC,sBAAsB,CAAC,EAAE,cAAc,CAAC,KAAK,EAAE;AACtF;AACA,MAAM,UAAU,GAAG,kBAAkB,CAAC,IAAI,EAAE,IAAI,EAAE,cAAc,EAAE,OAAO,CAAC,WAAW;AACrF,KAAK,MAAM;AACX,MAAM,MAAM,IAAI,KAAK,CAAC,CAAC,+BAA+B,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;AACrE;AACA,IAAI,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC;AAC5B;AACA,EAAE,IAAI,OAAO,CAAC,MAAM,GAAG,QAAQ,EAAE;AACjC,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,wBAAwB,EAAE,OAAO,CAAC,MAAM,CAAC,gCAAgC,EAAE,QAAQ,CAAC,CAAC,CAAC;AAC3G;AACA,EAAE,IAAI,OAAO,CAAC,MAAM,GAAG,QAAQ,EAAE;AACjC,IAAI,OAAO,CAAC,MAAM,GAAG,SAAQ;AAC7B;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,cAAc,CAAC,EAAE,sBAAsB,EAAE,gBAAgB,EAAE,qBAAqB,EAAE,EAAE;AACpG,EAAE,IAAI,YAAY,GAAG;AACrB,EAAE,IAAI,CAAC,YAAY,IAAI,gBAAgB,GAAG,YAAY,EAAE;AACxD,IAAI,YAAY,GAAG;AACnB;AACA,EAAE,OAAO,CAAC,YAAY,EAAE,YAAY,GAAG,qBAAqB;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,aAAa,CAAC,MAAM,EAAE;AAC/B,EAAE,MAAM,MAAM,GAAG,2BAA2B,CAAC,MAAM;;AAEnD;AACA,EAAE,MAAM,IAAI,GAAG,QAAQ,CAAC,MAAM,CAAC,OAAO;AACtC,EAAE,MAAM,sBAAsB,GAAG,MAAM,CAAC;AACxC,EAAE,MAAM,oBAAoB,GAAG,MAAM,CAAC;AACtC,EAAE,MAAM,GAAG,GAAG,MAAM,CAAC;AACrB,EAAE,MAAM,gBAAgB,GAAG,MAAM,CAAC,OAAO,IAAI;AAC7C,IAAI,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AACtC,IAAI,QAAQ,EAAE,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC;AAC9C,IAAI,yBAAyB,EAAE,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC;AAC/D,IAAI,yBAAyB,EAAE,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC;AAC/D,IAAI,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO,IAAI;AAC1C,MAAM,GAAG,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO;AACzC,MAAM,GAAG,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO;AACzC,MAAM,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO;AAChD,MAAM,cAAc,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO;AACpD,MAAM,SAAS,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO;AAC/C,MAAM,SAAS,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO;AAC/C,KAAK;AACL;AACA,EAAE,MAAM,iBAAiB,GAAG,MAAM,CAAC;AACnC,EAAE,MAAM,sBAAsB,GAAG,MAAM,CAAC,OAAO,IAAI;AACnD,IAAI,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AACtC,IAAI,QAAQ,EAAE,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC;AAC9C,IAAI,SAAS,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AACrC;AACA,EAAE,MAAM,mBAAmB,GAAG,MAAM,CAAC,OAAO,IAAI;AAChD,IAAI,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AACtC,IAAI,SAAS,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AACrC,IAAI,QAAQ,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AACpC,IAAI,QAAQ,EAAE,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC;AAC9C,IAAI,6BAA6B,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AACzD,IAAI,6BAA6B,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AACzD,IAAI,aAAa,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO,KAAK,SAAS,GAAG,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO;AACvF,IAAI,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO;AACtC;;AAEA,EAAE,OAAO;AACT,IAAI,IAAI;AACR,IAAI,sBAAsB;AAC1B,IAAI,oBAAoB;AACxB,IAAI,GAAG;AACP,IAAI,gBAAgB;AACpB,IAAI,iBAAiB;AACrB,IAAI,sBAAsB;AAC1B,IAAI,mBAAmB;AACvB;AACA;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,WAAW,CAAC,OAAO,EAAE;AAC3C,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,0BAA0B;;AAE/D;AACA,EAAE,OAAO,CAAC,QAAQ,KAAK,MAAM,oBAAoB,CAAC,OAAO,CAAC,IAAI;AAC9D,EAAE,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,MAAM,IAAI,KAAK,CAAC,4BAA4B;;AAErE,EAAE,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG;AAC3C,EAAE,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI;AACvC;AACA,EAAE,MAAM,OAAO,GAAG;;AAElB;AACA,EAAE,IAAI,UAAU,GAAG,EAAC;AACpB,EAAE,KAAK,MAAM,QAAQ,IAAI,QAAQ,CAAC,UAAU,EAAE;AAC9C;AACA,IAAI,MAAM,SAAS,GAAG,MAAM,CAAC,QAAQ,CAAC,QAAQ;AAC9C;AACA,IAAI,IAAI,UAAU,GAAG,SAAS,IAAI,QAAQ,KAAK,MAAM,KAAK,SAAS,IAAI,UAAU,GAAG,MAAM,CAAC,EAAE;AAC7F;AACA,MAAM,MAAM,QAAQ,GAAG,MAAM,IAAI,MAAM,GAAG;AAC1C,MAAM,MAAM,SAAS,GAAG,MAAM,YAAY,CAAC,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,QAAQ;AAClF,MAAM,IAAI,UAAU,EAAE;AACtB;AACA,QAAQ,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,UAAU,EAAE,CAAC;AACvD,QAAQ,MAAM,GAAG,GAAG,MAAM,KAAK,SAAS,GAAG,SAAS,GAAG,MAAM,GAAG;AAChE,QAAQ,MAAM,CAAC,OAAO,EAAE,SAAS,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC;AACnD;AACA;AACA,IAAI,UAAU,IAAI;AAClB;;AAEA,EAAE,IAAI,UAAU,EAAE,UAAU,CAAC,OAAO;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,YAAY,CAAC,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,QAAQ,EAAE;AAC5E,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG;AACtC,EAAE,IAAI,CAAC,QAAQ,EAAE,MAAM,IAAI,KAAK,CAAC,4BAA4B;AAC7D,EAAE,IAAI,QAAQ,KAAK,SAAS,IAAI,QAAQ,GAAG,QAAQ,CAAC,QAAQ,EAAE,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,QAAQ;;AAEjG;AACA,EAAE,IAAI,CAAC,cAAc,EAAE,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;AAC1D,EAAE,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,EAAE,SAAS,EAAE,cAAc,EAAE,KAAK;AAC9D,IAAI,IAAI,CAAC,cAAc,EAAE,MAAM,IAAI,KAAK,CAAC,sCAAsC;AAC/E;AACA,IAAI,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,EAAE;;AAExE,IAAI,MAAM,CAAC,eAAe,EAAE,aAAa,CAAC,GAAG,cAAc,CAAC,cAAc,CAAC,CAAC,GAAG,CAAC,MAAM;AACtF,IAAI,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,eAAe;AAC7D,IAAI,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,aAAa;AACvD,GAAG;AACH,EAAE,IAAI,cAAc,IAAI,YAAY,IAAI,OAAO,EAAE,MAAM,EAAE;AACzD;AACA,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,2BAA2B,EAAE,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;AACtE;AACA;AACA,EAAE,IAAI;AACN,EAAE,IAAI,YAAY,GAAG,cAAc,IAAI,CAAC,IAAI,EAAE,EAAE;AAChD;AACA;AACA,IAAI,WAAW,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,YAAY;AAC/D;;AAEA,EAAE,MAAM,QAAQ,GAAG;AACnB;AACA,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,aAAa,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3D,EAAE,MAAM,cAAc,GAAG,IAAI,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC;AAClG,EAAE,MAAM,aAAa,GAAG,IAAI,GAAG,GAAE;AACjC;AACA,EAAE,KAAK,IAAI,WAAW,GAAG,CAAC,EAAE,WAAW,GAAG,QAAQ,CAAC,OAAO,CAAC,MAAM,EAAE,WAAW,EAAE,EAAE;AAClF,IAAI,MAAM,cAAc,GAAG,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;AACzD,IAAI,IAAI,CAAC,cAAc,EAAE,MAAM,IAAI,KAAK,CAAC,sCAAsC;;AAE/E;AACA,IAAI,MAAM,UAAU,GAAG,cAAc,CAAC,cAAc,CAAC,CAAC;AACtD,IAAI,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;;AAElD,IAAI,MAAM,CAAC,eAAe,EAAE,aAAa,CAAC,GAAG,cAAc,CAAC,cAAc,CAAC,CAAC,GAAG,CAAC,MAAM;AACtF,IAAI,MAAM,WAAW,GAAG,aAAa,GAAG;;AAExC;AACA;AACA,IAAI,IAAI,WAAW,GAAG,CAAC,IAAI,EAAE,EAAE;AAC/B,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,8BAA8B,EAAE,cAAc,CAAC,cAAc,CAAC,EAAE,EAAE,WAAW,CAAC,cAAc,EAAE,CAAC,MAAM,CAAC;AAC1H;AACA,MAAM;AACN;;AAEA;AACA;AACA,IAAI,IAAI;AACR,IAAI,IAAI,YAAY,GAAG;AACvB,IAAI,IAAI,WAAW,EAAE;AACrB,MAAM,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,WAAW;AAC1C,MAAM,YAAY,GAAG,eAAe,GAAG;AACvC,KAAK,MAAM;AACX;AACA,MAAM,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,aAAa,CAAC;AACzE;;AAEA;AACA,IAAI,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,IAAI;AAC7C,MAAM,MAAM,UAAU,GAAG,aAAa,CAAC,QAAQ,CAAC,MAAM,EAAE,cAAc,CAAC,cAAc;AACrF,MAAM,MAAM,MAAM,GAAG,EAAE,IAAI,EAAE,IAAI,QAAQ,CAAC,WAAW,CAAC,EAAE,MAAM,EAAE,YAAY;AAC5E;AACA,MAAM,IAAI,UAAU,GAAG,UAAU,CAAC,MAAM,EAAE,QAAQ,EAAE,cAAc,EAAE,UAAU,EAAE,OAAO;AACvF;;AAEA;AACA;AACA,MAAM,MAAM,SAAS,GAAG,cAAc,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG;AAC9D,MAAM,aAAa,CAAC,GAAG,CAAC,SAAS,EAAE,UAAU;AAC7C,MAAM,UAAU,GAAG;;AAEnB,MAAM,MAAM,UAAU,GAAG,cAAc,CAAC,GAAG,CAAC,UAAU;AACtD,MAAM,IAAI,UAAU,EAAE,KAAK,CAAC,IAAI,IAAI,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE;AAC9D;AACA,QAAQ,cAAc,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC,CAAC;AACnD,QAAQ,UAAU,GAAG,aAAa,CAAC,GAAG,CAAC,UAAU;AACjD,QAAQ,IAAI,CAAC,UAAU,EAAE;AACzB,UAAU,MAAM,IAAI,KAAK,CAAC,CAAC,mCAAmC,EAAE,UAAU,CAAC,CAAC;AAC5E;AACA;;AAEA;AACA,MAAM,IAAI,CAAC,UAAU,EAAE;AACvB;AACA,MAAM,OAAO,CAAC,OAAO,GAAG;AACxB,QAAQ,UAAU;AAClB,QAAQ,UAAU;AAClB,QAAQ,QAAQ,EAAE,UAAU;AAC5B,QAAQ,MAAM,EAAE,UAAU,GAAG,UAAU,CAAC,MAAM;AAC9C,OAAO;AACP,KAAK,CAAC;AACN;AACA,EAAE,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ;AAC5B,EAAE,IAAI,OAAO,CAAC,UAAU,EAAE;AAC1B;AACA,IAAI,MAAM,SAAS,GAAG,IAAI,KAAK,CAAC,QAAQ;AACxC,IAAI,MAAM,mBAAmB,GAAG;AAChC,OAAO,GAAG,CAAC,KAAK,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI;AACtC,OAAO,MAAM,CAAC,IAAI,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC;AACxD,IAAI,MAAM,WAAW,GAAG,OAAO,IAAI;AACnC,IAAI,MAAM,eAAe,GAAG;AAC5B,OAAO,GAAG,CAAC,IAAI,IAAI,mBAAmB,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,SAAS;;AAE3F,IAAI,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,QAAQ,EAAE,GAAG,EAAE,EAAE;AAC7C,MAAM,IAAI,OAAO,CAAC,SAAS,KAAK,QAAQ,EAAE;AAC1C;AACA;AACA,QAAQ,MAAM,OAAO,GAAG;AACxB,QAAQ,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,KAAK,KAAK;AAC7C,UAAU,OAAO,CAAC,IAAI,CAAC,GAAG,eAAe,CAAC,KAAK,CAAC,GAAG,GAAG;AACtD,SAAS;AACT,QAAQ,SAAS,CAAC,GAAG,CAAC,GAAG;AACzB,OAAO,MAAM;AACb;AACA,QAAQ,SAAS,CAAC,GAAG,CAAC,GAAG,eAAe,CAAC,GAAG,CAAC,MAAM,IAAI,MAAM,GAAG,GAAG,CAAC;AACpE;AACA;AACA,IAAI,OAAO;AACX;AACA,EAAE,OAAO;AACT;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,aAAa,CAAC,MAAM,EAAE,MAAM,GAAG,EAAE,EAAE;AAC5C,EAAE,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE;AAC9B,IAAI,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,QAAQ,EAAE;AACzC,MAAM,aAAa,CAAC,KAAK,EAAE,MAAM;AACjC;AACA,GAAG,MAAM;AACT,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;AACrC;AACA,EAAE,OAAO;AACT;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,YAAY,CAAC,OAAO,EAAE;AAC5C,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG;AAC9C,EAAE,OAAO,CAAC,QAAQ,KAAK,MAAM,oBAAoB,CAAC,IAAI;;AAEtD;;AAEA,EAAE,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;AACnC;AACA,IAAI,MAAM,WAAW,GAAG,MAAM,kBAAkB,CAAC,EAAE,GAAG,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,CAAC,OAAO,CAAC,EAAE;;AAE3H;AACA,IAAI,MAAM,aAAa,GAAG,KAAK,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,EAAE,KAAK,KAAK,KAAK;AACrE,OAAO,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;AAC/E,OAAO,KAAK,CAAC,QAAQ,EAAE,MAAM;;AAE7B,IAAI,MAAM,UAAU,GAAG,MAAM,eAAe,CAAC,EAAE,GAAG,OAAO,EAAE,IAAI,EAAE,aAAa,EAAE;AAChF,IAAI,MAAM,IAAI,GAAG,aAAa,CAAC,GAAG,CAAC,KAAK,IAAI,UAAU,CAAC,KAAK,CAAC;AAC7D,IAAI,OAAO;AACX,GAAG,MAAM;AACT,IAAI,OAAO,MAAM,kBAAkB,CAAC,OAAO;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe,CAAC,OAAO,EAAE;AACxC,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG;AACzB,EAAE,OAAO,CAAC,QAAQ,KAAK,MAAM,oBAAoB,CAAC,IAAI;AACtD,EAAE,MAAM,EAAE,UAAU,EAAE,SAAS,EAAE,GAAG,OAAO,CAAC;AAC5C;AACA,EAAE,MAAM,aAAa,GAAG,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK;AAC1D,EAAE,IAAI,UAAU,GAAG;AACnB,EAAE,MAAM,SAAS,GAAG,SAAS,CAAC,GAAG,CAAC,KAAK,IAAI,UAAU,IAAI,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC;AAC/E,EAAE,KAAK,MAAM,KAAK,IAAI,IAAI,EAAE;AAC5B,IAAI,MAAM,UAAU,GAAG,SAAS,CAAC,SAAS,CAAC,GAAG,IAAI,KAAK,GAAG,GAAG;AAC7D,IAAI,aAAa,CAAC,UAAU,CAAC,GAAG;AAChC;;AAEA;AACA,EAAE,MAAM,SAAS,GAAG;AACpB,EAAE,IAAI;AACN,EAAE,UAAU,GAAG;AACf,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACjD,IAAI,MAAM,QAAQ,GAAG,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,QAAQ;AAC9D,IAAI,IAAI,aAAa,CAAC,CAAC,CAAC,EAAE;AAC1B,MAAM,IAAI,UAAU,KAAK,SAAS,EAAE;AACpC,QAAQ,UAAU,GAAG;AACrB;AACA,KAAK,MAAM;AACX,MAAM,IAAI,UAAU,KAAK,SAAS,EAAE;AACpC,QAAQ,SAAS,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,QAAQ,CAAC;AAC7C,QAAQ,UAAU,GAAG;AACrB;AACA;AACA,IAAI,UAAU,GAAG;AACjB;AACA,EAAE,IAAI,UAAU,KAAK,SAAS,EAAE;AAChC,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,UAAU,CAAC;AAC3C;;AAEA;AACA,EAAE,MAAM,UAAU,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC;AAChE,EAAE,KAAK,MAAM,CAAC,UAAU,EAAE,QAAQ,CAAC,IAAI,SAAS,EAAE;AAClD;AACA,IAAI,MAAM,SAAS,GAAG,MAAM,kBAAkB,CAAC,EAAE,GAAG,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,MAAM,EAAE,QAAQ,EAAE;AACrG,IAAI,KAAK,IAAI,CAAC,GAAG,UAAU,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE;AAChD,MAAM,UAAU,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,GAAG,UAAU;AAC9C,MAAM,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,GAAG;AAChC;AACA;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE;AACvB,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC;AACrB,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,OAAO;AACpB,EAAE,OAAO,CAAC;AACV;;ACxFA;AACA;AACA;AACA;AACO,SAAS,kBAAkB,CAAC,OAAO,EAAE;AAC5C,EAAE,OAAO,IAAI,OAAO,CAAC,CAAC,UAAU,EAAE,MAAM,KAAK;AAC7C,IAAI,WAAW,CAAC;AAChB,MAAM,SAAS,EAAE,QAAQ;AACzB,MAAM,GAAG,OAAO;AAChB,MAAM,UAAU;AAChB,KAAK,CAAC,CAAC,KAAK,CAAC,MAAM;AACnB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA,MAAM,iBAAiB,GAAG;AAC1B,MAAM,sBAAsB,GAAG;AAC/B,MAAM,mBAAmB,GAAG;AAG5B,MAAM,wBAAwB,GAAG;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,SAAS,CAAC,GAAG,EAAE;AAC/B,EAAE,IAAI,MAAM,GAAG;;AAEf;AACA,EAAE,MAAM,SAAS,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI;AAC3C,EAAE,MAAM,cAAc,IAAI,SAAS,KAAK,CAAC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,SAAS,UAAU,CAAC,GAAG,EAAE,GAAG,EAAE;AAChC,IAAI,MAAM,EAAE,GAAG,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU;AACtE,IAAI,OAAO,EAAE,CAAC,SAAS,CAAC,GAAG,EAAE,cAAc;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,SAAS,UAAU,CAAC,GAAG,EAAE,GAAG,EAAE;AAChC,IAAI,MAAM,EAAE,GAAG,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU;AACtE,IAAI,OAAO,EAAE,CAAC,UAAU,CAAC,GAAG,EAAE,cAAc;AAC5C;;AAEA;AACA,EAAE,MAAM,YAAY,GAAG,UAAU,CAAC,GAAG,EAAE,MAAM;AAC7C,EAAE,MAAM,IAAI;;AAEZ;AACA,EAAE,IAAI,YAAY,KAAK,iBAAiB,EAAE;AAC1C;AACA,IAAI,MAAM,CAAC,GAAG,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI;AACjD,IAAI,MAAM,CAAC,GAAG,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI;AACjD,IAAI,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,WAAW,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,GAAG,MAAM,IAAI,YAAY,KAAK,sBAAsB,EAAE;AACtD;AACA,IAAI,MAAM,SAAS,GAAG,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI;AACzD,IAAI,MAAM,MAAM,GAAG;AACnB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;AACxC,MAAM,MAAM,CAAC,GAAG,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI;AACnD,MAAM,MAAM,CAAC,GAAG,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI;AACnD,MAAM,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB;AACA,IAAI,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,WAAW,EAAE,MAAM;AACpD,GAAG,MAAM,IAAI,YAAY,KAAK,mBAAmB,EAAE;AACnD;AACA,IAAI,MAAM,QAAQ,GAAG,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI;AACxD,IAAI,MAAM,MAAM,GAAG;AACnB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE;AACvC,MAAM,MAAM,SAAS,GAAG,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI;AAC3D,MAAM,MAAM,IAAI,GAAG;AACnB,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;AAC1C,QAAQ,MAAM,CAAC,GAAG,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI;AACrD,QAAQ,MAAM,CAAC,GAAG,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI;AACrD,QAAQ,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB;AACA,MAAM,MAAM,CAAC,IAAI,CAAC,IAAI;AACtB;AACA,IAAI,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,WAAW,EAAE,MAAM;;AAEjD,GAAG,MAAM,IAAI,YAAY,KAAK,wBAAwB,EAAE;AACxD;AACA,IAAI,MAAM,WAAW,GAAG,UAAU,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI;AAC3D,IAAI,MAAM,QAAQ,GAAG;AACrB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE;AAC1C;AACA,MAAM,MAAM,WAAW,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI;AACjD,MAAM,MAAM,gBAAgB,IAAI,WAAW,KAAK,CAAC;AACjD,MAAM,MAAM,MAAM,GAAG,CAAC,WAAW;AACjC,QAAQ,MAAM,EAAE,GAAG,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU;AAC1E,QAAQ,MAAM,GAAG,GAAG,EAAE,CAAC,SAAS,CAAC,MAAM,EAAE,gBAAgB;AACzD,QAAQ,MAAM,IAAI;AAClB,QAAQ,OAAO;AACf,OAAO;;AAEP,MAAM,IAAI,MAAM,KAAK,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,sCAAsC,EAAE,MAAM,CAAC,CAAC;;AAEzF,MAAM,MAAM,QAAQ,GAAG,CAAC,WAAW;AACnC,QAAQ,MAAM,EAAE,GAAG,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU;AAC1E,QAAQ,MAAM,GAAG,GAAG,EAAE,CAAC,SAAS,CAAC,MAAM,EAAE,gBAAgB;AACzD,QAAQ,MAAM,IAAI;AAClB,QAAQ,OAAO;AACf,OAAO;;AAEP,MAAM,MAAM,QAAQ,GAAG;AACvB,MAAM,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE;AACzC,QAAQ,MAAM,SAAS,GAAG,CAAC,WAAW;AACtC,UAAU,MAAM,EAAE,GAAG,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU;AAC5E,UAAU,MAAM,GAAG,GAAG,EAAE,CAAC,SAAS,CAAC,MAAM,EAAE,gBAAgB;AAC3D,UAAU,MAAM,IAAI;AACpB,UAAU,OAAO;AACjB,SAAS;AACT,QAAQ,MAAM,IAAI,GAAG;AACrB,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;AAC5C,UAAU,MAAM,EAAE,GAAG,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU;AAC5E,UAAU,MAAM,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,MAAM,EAAE,gBAAgB,CAAC,CAAC,CAAC,MAAM,IAAI;AACvE,UAAU,MAAM,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,MAAM,EAAE,gBAAgB,CAAC,CAAC,CAAC,MAAM,IAAI;AACvE,UAAU,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB;AACA,QAAQ,QAAQ,CAAC,IAAI,CAAC,IAAI;AAC1B;AACA,MAAM,QAAQ,CAAC,IAAI,CAAC,QAAQ;AAC5B;AACA,IAAI,OAAO,EAAE,IAAI,EAAE,cAAc,EAAE,WAAW,EAAE,QAAQ;AACxD,GAAG,MAAM;AACT,IAAI,MAAM,IAAI,KAAK,CAAC,6BAA6B,GAAG,YAAY;AAChE;AACA;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,kBAAkB,CAAC,WAAW,EAAE;AACtD,EAAE,MAAM,QAAQ,GAAG,MAAM,oBAAoB,CAAC,WAAW;AACzD,EAAE,MAAM,WAAW,GAAG,QAAQ,CAAC,kBAAkB,EAAE,IAAI,CAAC,EAAE,IAAI,EAAE,CAAC,GAAG,KAAK,KAAK;AAC9E,EAAE,IAAI,CAAC,WAAW,EAAE;AACpB,IAAI,MAAM,IAAI,KAAK,CAAC,iDAAiD;AACrE;AACA,EAAE,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,IAAI,IAAI;AACxD,EAAE,OAAO,CAAC,GAAG,CAAC,oBAAoB,EAAE,SAAS;;AAE7C;AACA,EAAE,MAAM,IAAI,GAAG,MAAM,YAAY,CAAC,EAAE,IAAI,EAAE,WAAW,EAAE;AACvD,EAAE,OAAO,CAAC,GAAG,CAAC,kBAAkB,EAAE,MAAM,CAAC,IAAI,CAAC;;AAE9C;AACA;AACA;AACA;AACA;AACA,EAAE,MAAM,QAAQ,GAAG;;AAEnB;AACA;AACA,EAAE,MAAM,aAAa,GAAG,SAAS,CAAC,cAAc,IAAI;;AAEpD,EAAE,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;AAC1B,IAAI,MAAM,MAAM,GAAG,GAAG,CAAC,aAAa;AACpC,IAAI,IAAI,CAAC,MAAM,EAAE;AACjB;AACA,MAAM;AACN;;AAEA;AACA;AACA,IAAI,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,MAAM;AAC/C,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC5C,MAAM,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC;AACrC;;AAEA;AACA;;AAEA,IAAI,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM;;AAErC;AACA;AACA,IAAI,MAAM,UAAU,GAAG;AACvB,IAAI,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;AACxC,MAAM,IAAI,GAAG,KAAK,aAAa,EAAE;AACjC,QAAQ,UAAU,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG;AACjC;AACA;;AAEA;AACA,IAAI,MAAM,OAAO,GAAG;AACpB,MAAM,IAAI,EAAE,SAAS;AACrB,MAAM,QAAQ;AACd,MAAM;AACN;;AAEA,IAAI,QAAQ,CAAC,IAAI,CAAC,OAAO;AACzB;;AAEA,EAAE,OAAO;AACT,IAAI,IAAI,EAAE,mBAAmB;AAC7B,IAAI,QAAQ;AACZ;AACA;;ACxEA,IAAI;;AAEJ,MAAM,CAAC,OAAO,GAAG,eAAe,cAAc,GAAG;AACjD;AACA,EAAE,MAAM,GAAG,GAAG,QAAQ,CAAC,cAAc,CAAC,KAAK;AAC3C,EAAE,GAAG,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE;AACjC,IAAI,MAAM,EAAE,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,OAAO,EAAE;AAC3C,IAAI,IAAI,EAAE,CAAC;AACX,GAAG;;AAEH;AACA,EAAE,MAAM,UAAU,GAAG;;AAErB,EAAE,IAAI;AACN;AACA,IAAI,MAAM,WAAW,GAAG,MAAM,kBAAkB,CAAC,EAAE,GAAG,EAAE,UAAU,EAAE;AACpE,IAAI,MAAM,OAAO,GAAG,MAAM,kBAAkB,CAAC,WAAW;;AAExD;AACA,IAAI,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO;AAC/B,GAAG,CAAC,OAAO,KAAK,EAAE;AAClB,IAAI,OAAO,CAAC,KAAK,CAAC,2CAA2C,EAAE,KAAK;AACpE;AACA","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}